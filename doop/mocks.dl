// ./doop -a context-insensitive -i ~/hacking/MockAbstraction/Benchmarks/microbenchmark/target/payroll-test-0.0.1-SNAPSHOT.jar -i ~/hacking/MockAbstraction/Benchmarks/microbenchmark/target/payroll-test-0.0.1-SNAPSHOT-tests.jar -i ~/hacking/MockAbstraction/Benchmarks/microbenchmark/mvn_dependencies/ --id context-insensitive-with-mocks --souffle-jobs 32 --main ca.liang.RootDriver --extra-logic souffle-logic/analyses/mocks/mocks.dl

#include "../../basic/type-hierarchy.dl"
#include "../../basic/method-lookup.dl"

// m: Method
.decl MockSourceMethod(m: Method)
MockSourceMethod("<org.easymock.EasyMock: java.lang.Object createMock(java.lang.Class)>").
MockSourceMethod("<org.mockito.Mockito: java.lang.Object mock(java.lang.Class)>").
MockSourceMethod("<org.powermock.api.mockito.PowerMockito: java.lang.Object mock(java.lang.Class)>").
MockSourceMethod("<org.mockito.Mockito: java.lang.Object verify(java.lang.Object,org.mockito.verification.VerificationMode)>").
MockSourceMethod("<org.mockito.internal.MockitoCore: java.lang.Object verify(java.lang.Object)>").
MockSourceMethod("<org.mockito.internal.InOrderImpl: java.lang.Object verify(java.lang.Object)>").
MockSourceMethod("<org.mockito.internal.MockitoCore: java.lang.Object verify(java.lang.Object,org.mockito.verification.VerificationMode)>").
MockSourceMethod("<org.mockito.internal.InOrderImpl: java.lang.Object verify(java.lang.Object,org.mockito.verification.VerificationMode)>").

.decl MockFieldAnnotation(a: Annotation)
MockFieldAnnotation("org.mockito.Mock").

// TODO handle addAll
.decl CollectionPutMethod(m:Method)
CollectionPutMethod("<java.util.Collection: boolean add(java.lang.Object)>").
CollectionPutMethod(m) :-
  CollectionPutMethod(m0),
  MethodOverridesOther(m, m0).

.decl CollectionGetMethod(m:Method)
CollectionGetMethod("<java.util.List: java.lang.Object get(int)>").
CollectionGetMethod(m) :-
  CollectionGetMethod(m0),
  MethodOverridesOther(m, m0).

.decl callsMockSource(mi: MethodInvocation)
callsMockSource(mi) :-
  MockSourceMethod(ms),
  mainAnalysis.CallGraphEdge(_, mi, _, ms).
.output callsMockSource

.decl isInterprocMockVar(v:Var)
isInterprocMockVar(v) :-
  AssignReturnValue(mi, v),
  mainAnalysis.CallGraphEdge(_, mi, _, callee),
  ReturnVar(v_callee, callee),
  isMockVar(v_callee).
.output isInterprocMockVar

// v:Var
.decl isMockVar(v: Var)
isMockVar(v) :-
  isInterprocMockVar(v).
isMockVar(v) :-
  AssignReturnValue(mi, v),
  callsMockSource(mi).
isMockVar(v) :-
  isMockVar(from),
  AssignCast(_ /* type */, from, v, _ /* inmethod */).
isMockVar(v) :-
  isMockVar(v1),
  AssignLocal(v1, v, _).
isMockVar(v) :-
  LoadInstanceField(_, field, v, _),
  fieldContainsMock(field).
isMockVar(v) :-
// v = c.get(_);
  isCollectionLocalThatContainsMocks(c, _),
  CollectionGetMethod(get),
  VirtualMethodInvocation(mi, get, _),
  VirtualMethodInvocation_Base(mi, c),
  AssignReturnValue(mi, v).
isMockVar(v) :-
// v = c[_];
  isArrayLocalThatContainsMocks(c),
  LoadArrayIndex(c, v, _).
.output isMockVar

.decl isCollectionLocalThatContainsMocks(c:Var, inmethod:symbol)
// c.add(mv)
isCollectionLocalThatContainsMocks(c, inmethod) :-
  CollectionPutMethod(put),
  VirtualMethodInvocation(mi, put, inmethod),
  VirtualMethodInvocation_Base(mi, c),
  ActualParam(0, mi, mv),
  isMockVar(mv).
isCollectionLocalThatContainsMocks(c, inmethod) :-
  isCollectionFieldThatContainsMocks(f),
  LoadInstanceField(_, f, c, inmethod).
isCollectionLocalThatContainsMocks(c, inmethod) :-
  isCollectionLocalThatContainsMocks(c1, inmethod),
  AssignLocal(c1, c, inmethod).
.output isCollectionLocalThatContainsMocks

.decl isCollectionFieldThatContainsMocks(f:Field)
// base.f = c where c is a CollectionLocalThatContainsMocks -> f is a field that contains mocks
isCollectionFieldThatContainsMocks(f) :-
  isCollectionLocalThatContainsMocks(c, _),
  StoreInstanceField(c, _, f, _).
.output isCollectionFieldThatContainsMocks

.decl isInterprocArrayLocalThatContainsMocks(c:Var)
isInterprocArrayLocalThatContainsMocks(v) :-
  AssignReturnValue(mi, v),
  mainAnalysis.CallGraphEdge(_, mi, _, callee),
  ReturnVar(v_callee, callee),
  isArrayLocalThatContainsMocks(v_callee).
.output isInterprocArrayLocalThatContainsMocks

.decl isArrayLocalThatContainsMocks(c:Var)
// c[idx] = mv @ insn
isArrayLocalThatContainsMocks(c) :-
  StoreArrayIndex(mv, c, _),
  isMockVar(mv).
// c = _.f, f contains mocks
isArrayLocalThatContainsMocks(c) :-
  isArrayFieldThatContainsMocks(f),
  LoadInstanceField(_, f, c, _).
isArrayLocalThatContainsMocks(c) :-
  isArrayLocalThatContainsMocks(c1),
  AssignLocal(c1, c, _).
isArrayLocalThatContainsMocks(v) :-
  isInterprocArrayLocalThatContainsMocks(v).
.output isArrayLocalThatContainsMocks

.decl isArrayFieldThatContainsMocks(f:Field)
// arr = _.f <- (2) propagates so that field f is a field that contains mocks
// arr[i] = mv <- (1) marks arr as an arraylocalthatcontainsmocks
isArrayFieldThatContainsMocks(f) :-
  isArrayLocalThatContainsMocks(arr),
  LoadInstanceField(_, f, arr, _).
.output isArrayFieldThatContainsMocks

.decl isMockInvocation(mi: MethodInvocation, signature:Method, inMethod:Method, line: number, receiver: symbol)
isMockInvocation(mi, signature, inmethod, line, receiver) :-
  _MethodInvocation_Line(mi, line),
  VirtualMethodInvocation(mi, signature, inmethod),
  VirtualMethodInvocation_Base(mi, receiver),
  isMockVar(receiver).
.output isMockInvocation

// .decl LoadInstanceField(?base:Var, ?sig:Field, ?to:Var, ?inmethod:Method)
// .decl StoreInstanceField(?from:Var, ?base:Var, ?signature:Field, ?inmethod: Method)
.decl fieldContainsMock(signature: Field)
fieldContainsMock(signature) :-
  StoreInstanceField(from, _, signature, _),
  isMockVar(from).
fieldContainsMock(signature) :-
  Field_Annotation(signature, a),
  MockFieldAnnotation(a).
.output fieldContainsMock

.output CollectionPutMethod
.output VirtualMethodInvocation_Base
.output VirtualMethodInvocation
.output ActualParam
.output AssignReturnValue
.output StoreInstanceField
.output LoadInstanceField
.output LoadArrayIndex

// -- cut here --
// .decl VarPointsTo(hctx:symbol, heap:symbol, ctx:symbol, var:symbol)
// .input VarPointsTo(IO="file", filename="VarPointsTo.csv", delimiter="\t")

/* let's try putting in points-to */
// doesn't do anything?
/*isMockVar(v) :-
  MockVarVPT(h1, v),
  MockVarVPT(h1, v1),
  Var_Type(v, t),
  Var_Type(v1, t).*/
// doesn't do anything?
/*isMockVar(v) :-
  isMockVar(from),
  AssignLocal_From(insn, from),
  AssignInstruction_To(insn, v).
.decl MockVarVPT(h:symbol, v:Var)
MockVarVPT(h,v) :-
  isMockVar(v),
  VarPointsTo(_, h, _, v).
*/

/* expensive
isMockVar(v) :-
  isMockVar(v1),
  VarPointsTo(_, h1, _, v),
  VarPointsTo(_, h1, _, v1),
  Var_Type(v, t),
  Var_Type(v1, t).
*/

// reference info
//  VirtualMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)  

// we want this to be identified as mock
// AssignReturnValue.facts:<ca.liang.PayRollMockTest: void testNoEmployeesIntra()>/ca.liang.EmployeeDB.getAllEmployees/0   <ca.liang.PayRollMockTest: void testNoEmployeesIntra()>/$stack9
// VirtualMethodInvocation.facts:<ca.liang.PayRollMockTest: void testNoEmployeesIntra()>/ca.liang.EmployeeDB.getAllEmployees/0     11      <ca.liang.EmployeeDB: java.util.List getAllEmployees()> <ca.liang.PayRollMockTest: void testNoEmployeesIntra()>/employeeDB_intra#_47    <ca.liang.PayRollMockTest: void testNoEmployeesIntra()>
// yet stack9 isn't a mock, why?
// we don't have any assignments to it here
// and it's not at all in VarPointsTo


// ok let's debug the different meanings of methodinvocation
// line, receiver  54      <ca.liang.PayRollArrayMockTest: void testEmployeesPaidIntra()>/bankService_intra#_55
// VirtualMethodInvocation:
//  <ca.liang.PayRollMockTest: void testNoEmployeesIntra()>/ca.liang.PayRoll.monthlyPayment/0       <ca.liang.PayRoll: int monthlyPayment()>        <ca.liang.PayRollMockTest: void testNoEmployeesIntra()>
// ActualParam:
//  <ca.liang.PayRollMockTest: void testNoEmployeesIntra()>/ca.liang.PayRoll.<init>/0
// 


/* identifying employeeDB.getAllEmployees() as a call to a mock:
it is a VirtualMethodInvocation on employeeDB_intra#_47 as follows,
* <ca.liang.PayRollMockTest: void testNoEmployeesIntra()>/ca.liang.EmployeeDB.getAllEmployees/0   11      <ca.liang.EmployeeDB: java.util.List getAllEmployees()> <ca.liang.PayRollMockTest: void testNoEmployeesIntra()>/employeeDB_intra#_47    <ca.liang.PayRollMockTest: void testNoEmployeesIntra()>
intra#_47 is assigned from AssignCast from <ca.liang.PayRollMockTest: void testNoEmployeesIntra()>/\$stack7
* OK <ca.liang.PayRollMockTest: void testNoEmployeesIntra()>/assign/instruction7	7	<ca.liang.PayRollMockTest: void testNoEmployeesIntra()>/$stack7	<ca.liang.PayRollMockTest: void testNoEmployeesIntra()>/employeeDB_intra#_47	ca.liang.EmployeeDB	<ca.liang.PayRollMockTest: void testNoEmployeesIntra()>
stack7 is assigned in AssignReturnValue:
<ca.liang.PayRollMockTest: void testNoEmployeesIntra()>/org.mockito.Mockito.mock/0	<ca.liang.PayRollMockTest: void testNoEmployeesIntra()>/$stack7
and the method occurs in both mainAnalysis.CallGraphEdge and StaticMethodInvocation
* OK mainAnalysis.CallGraphEdge: <<immutable-context>>	    <ca.liang.PayRollMockTest: void testNoEmployeesIntra()>/org.mockito.Mockito.mock/0	<<immutable-context>>	<org.mockito.Mockito: java.lang.Object mock(java.lang.Class)>
* OK StaticMethodInvocation: <ca.liang.PayRollMockTest: void testNoEmployeesIntra()>/org.mockito.Mockito.mock/0			5			<org.mockito.Mockito: java.lang.Object mock(java.lang.Class)>	<ca.liang.PayRollMockTest: void testNoEmployeesIntra()>
*/

// ok, so we start with the staticmethodinvocation, then we look for an assignreturnvalue, then assigncast, through the virtualmethodinvocation of interest
// basically this is pretty equivalent to doing the flow analysis


/*
// experimenting with points-to
.decl Var_DeclaringMethod(v: symbol, m: symbol)
.input Var_DeclaringMethod(IO="file", filename="Var-DeclaringMethod.facts", delimiter="\t")

// VarPointsTo: hctx:HContext, heap:HeapAllocation, ctx:Context, var:Var
.decl VarPointsTo(c1: symbol, h: symbol, c2: symbol, v: symbol)
.input VarPointsTo(IO="file", filename="VarPointsTo.csv", delimiter="\t")

.decl Temp(v: symbol, h: symbol)
Temp(v,h) :-
  VarPointsTo(_, h, _, v),
  Var_DeclaringMethod(v, "<ca.liang.PayRollMockTest: void testNoEmployeesIntra()>").
.output Temp
*/

/*
.decl thisIsMock(mi: MethodInvocation, receiver: symbol)
thisIsMock(mi, receiver) :-
  ActualParam(0, mi, receiver),
  // oops assign isn't actually a relation
  //Move(intermediate, receiver),
  isMockVar(receiver).
.output thisIsMock
*/
