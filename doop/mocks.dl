// ./doop -a context-insensitive -i ~/hacking/MockAbstraction/Benchmarks/microbenchmark/target/payroll-test-0.0.1-SNAPSHOT.jar -i ~/hacking/MockAbstraction/Benchmarks/microbenchmark/target/payroll-test-0.0.1-SNAPSHOT-tests.jar -i ~/hacking/MockAbstraction/Benchmarks/microbenchmark/mvn_dependencies/ --id context-insensitive-with-mocks --souffle-jobs 32 --main ca.liang.RootDriver --extra-logic souffle-logic/analyses/mocks/mocks.dl

// these are mostly used in isMockVar, but the places where we combine two things will have specific #ifdef tests also
#define INTERPROC 1
#define COLLECTIONS 1
#define ARRAYS 1
#define FIELDS 1

// MainClass("ca.liang.RootDriver").

// m: Method
.decl MockSourceMethod(m: Method)
MockSourceMethod("<org.easymock.EasyMock: java.lang.Object createMock(java.lang.Class)>").
MockSourceMethod("<org.mockito.Mockito: java.lang.Object mock(java.lang.Class)>").
MockSourceMethod("<org.powermock.api.mockito.PowerMockito: java.lang.Object mock(java.lang.Class)>").
MockSourceMethod("<org.mockito.Mockito: java.lang.Object verify(java.lang.Object)>").
MockSourceMethod("<org.mockito.Mockito: java.lang.Object verify(java.lang.Object,org.mockito.verification.VerificationMode)>").
MockSourceMethod("<org.mockito.internal.MockitoCore: java.lang.Object verify(java.lang.Object)>").
MockSourceMethod("<org.mockito.internal.InOrderImpl: java.lang.Object verify(java.lang.Object)>").
MockSourceMethod("<org.mockito.internal.MockitoCore: java.lang.Object verify(java.lang.Object,org.mockito.verification.VerificationMode)>").
MockSourceMethod("<org.mockito.internal.InOrderImpl: java.lang.Object verify(java.lang.Object,org.mockito.verification.VerificationMode)>").

.decl MockFieldAnnotation(a: Annotation)
MockFieldAnnotation("org.mockito.Mock").

// List.add(int,Object); addAll(int,Collection); listIterator(int); .set(int,Object)
// subList, toArray
// stream, parallelStream

.decl CollectionPutMethod(m:Method)
CollectionPutMethod("<java.util.Collection: boolean add(java.lang.Object)>").
CollectionPutMethod("<java.util.List: void add(int,java.lang.Object)>").
CollectionPutMethod("<java.util.List: java.lang.Object set(int,java.lang.Object)>").
CollectionPutMethod(m) :-
  CollectionPutMethod(m0),
  basic.MethodOverridesOther(m, m0).
CollectionPutMethod(m) :-
  CollectionPutMethod(m0),
  Method_DeclaringType(m, t),
  Method_DeclaringType(m0, t0),
  SameMethodExceptDeclaringType(m, m0),
  basic.Superinterface(t0, t).

.decl CollectionAddAllMethod(m:Method)
CollectionAddAllMethod("<java.util.Collection: boolean addAll(java.util.Collection)>").
CollectionAddAllMethod("<java.util.List: boolean addAll(int,java.util.Collection)>").
CollectionAddAllMethod(m) :-
  CollectionAddAllMethod(m0),
  basic.MethodOverridesOther(m, m0).
CollectionAddAllMethod(m) :-
  CollectionAddAllMethod(m0),
  Method_DeclaringType(m, t),
  Method_DeclaringType(m0, t0),
  SameMethodExceptDeclaringType(m, m0),
  basic.Superinterface(t0, t).

.decl CollectionGetMethod(m:Method)
CollectionGetMethod("<java.util.List: java.lang.Object get(int)>").
CollectionGetMethod("<java.util.Iterator: java.lang.Object next()>").
CollectionGetMethod("<java.util.ListIterator: java.lang.Object previous()>").
// ... also, forEachRemaining()
CollectionGetMethod(m) :-
  CollectionGetMethod(m0),
  basic.MethodOverridesOther(m, m0).
CollectionGetMethod(m) :-
  CollectionGetMethod(m0),
  Method_DeclaringType(m, t),
  Method_DeclaringType(m0, t0),
  SameMethodExceptDeclaringType(m, m0),
  basic.Superinterface(t0, t).

.decl CollectionIteratorMethod(m:Method)
CollectionIteratorMethod("<java.util.Iterable: java.util.Iterator iterator()>").
CollectionIteratorMethod("<java.util.Collection: java.util.Iterator iterator()>").
CollectionIteratorMethod("<java.util.List: java.util.ListIterator listIterator()>").
CollectionIteratorMethod("<java.util.List: java.util.ListIterator listIterator(int)>").
CollectionIteratorMethod(m) :-
  CollectionIteratorMethod(m0),
  basic.MethodOverridesOther(m, m0).
CollectionIteratorMethod(m) :-
  CollectionIteratorMethod(m0),
  Method_DeclaringType(m, t),
  Method_DeclaringType(m0, t0),
  SameMethodExceptDeclaringType(m, m0),
  basic.Superinterface(t0, t).

.decl SameMethodExceptDeclaringType(m:Method, m0:Method)
SameMethodExceptDeclaringType(m, m0) :-
  Method_SimpleName(m, n),
  Method_SimpleName(m0, n),
  Method_Descriptor(m, d),
  Method_Descriptor(m0, d).

.decl callsMockSource(mi: MethodInvocation)
callsMockSource(mi) :-
  MockSourceMethod(ms),
  mainAnalysis.CallGraphEdge(_, mi, _, ms).
.output callsMockSource

// v:Var
.decl isMockVar(v: Var)
isMockVar(v) :-
  AssignReturnValue(mi, v),
  callsMockSource(mi).
isMockVar(v) :-
  isMockVar(from),
  AssignCast(_ /* type */, from, v, _ /* inmethod */).
isMockVar(v) :-
  isMockVar(v1),
  AssignLocal(v1, v, _).
#ifdef INTERPROC
isMockVar(v) :-
  isInterprocMockVar(v).
#endif
#ifdef FIELDS
isMockVar(v) :-
  LoadInstanceField(_, field, v, _),
  fieldContainsMock(field).
#endif
#ifdef COLLECTIONS
isMockVar(v) :-
// v = c.get(_);
  isCollectionLocalThatContainsMocks(c, _),
  CollectionGetMethod(get),
  VirtualMethodInvocation(mi, get, _),
  VirtualMethodInvocation_Base(mi, c),
  AssignReturnValue(mi, v).
#endif
#ifdef ARRAYS
isMockVar(v) :-
// v = c[_];
  isArrayLocalThatContainsMocks(c),
  LoadArrayIndex(c, v, _).
#endif
.output isMockVar

.decl isMockInvocation(mi: MethodInvocation, signature:Method, inMethod:Method, line: number, receiver: symbol)
isMockInvocation(mi, signature, inmethod, line, receiver) :-
  _MethodInvocation_Line(mi, line),
  VirtualMethodInvocation(mi, signature, inmethod),
  VirtualMethodInvocation_Base(mi, receiver),
  isMockVar(receiver).
.output isMockInvocation

// ** interprocedural
.decl isInterprocMockVar(v:Var)
isInterprocMockVar(v) :-
  AssignReturnValue(mi, v),
  mainAnalysis.CallGraphEdge(_, mi, _, callee),
  ReturnVar(v_callee, callee),
  isMockVar(v_callee).
.output isInterprocMockVar

// ** collections
.decl isCollectionLocalThatContainsMocks(c:Var, inmethod:symbol)
// c.add(mv)
isCollectionLocalThatContainsMocks(c, inmethod) :-
  CollectionPutMethod(put),
  VirtualMethodInvocation(mi, put, inmethod),
  VirtualMethodInvocation_Base(mi, c),
  ActualParam(_, mi, mv),
  isMockVar(mv).
// c = _.f
isCollectionLocalThatContainsMocks(c, inmethod) :-
  isCollectionFieldThatContainsMocks(f),
  LoadInstanceField(_, f, c, inmethod).
// c1 = c
isCollectionLocalThatContainsMocks(c, inmethod) :-
  isCollectionLocalThatContainsMocks(c1, inmethod),
  AssignLocal(c1, c, inmethod).
// c.addAll(c1)
isCollectionLocalThatContainsMocks(c, inmethod) :-
  isCollectionLocalThatContainsMocks(c1, inmethod),
  CollectionAddAllMethod(add_all),
  VirtualMethodInvocation(mi, add_all, inmethod),
  VirtualMethodInvocation_Base(mi, c),
  ActualParam(_, mi, c1).
// it = c.iterator()
isCollectionLocalThatContainsMocks(it, inmethod) :-
  isCollectionLocalThatContainsMocks(c, inmethod),
  CollectionIteratorMethod(it_method),
  VirtualMethodInvocation(mi, it_method, inmethod),
  VirtualMethodInvocation_Base(mi, c),
  AssignReturnValue(mi, it).
.output isCollectionLocalThatContainsMocks

// ** collections \times fields
.decl isCollectionFieldThatContainsMocks(f:Field)
// base.f = c where c is a CollectionLocalThatContainsMocks -> f is a field that contains mocks
#ifdef FIELDS
isCollectionFieldThatContainsMocks(f) :-
  isCollectionLocalThatContainsMocks(c, _),
  StoreInstanceField(c, _, f, _).
#endif
.output isCollectionFieldThatContainsMocks

// ** arrays
.decl isInterprocArrayLocalThatContainsMocks(c:Var)
#ifdef INTERPROC
isInterprocArrayLocalThatContainsMocks(v) :-
  AssignReturnValue(mi, v),
  mainAnalysis.CallGraphEdge(_, mi, _, callee),
  ReturnVar(v_callee, callee),
  isArrayLocalThatContainsMocks(v_callee).
#endif
.output isInterprocArrayLocalThatContainsMocks

.decl isArrayLocalThatContainsMocks(c:Var)
// c[idx] = mv @ insn
isArrayLocalThatContainsMocks(c) :-
  StoreArrayIndex(mv, c, _),
  isMockVar(mv).
// c = _.f, f contains mocks
isArrayLocalThatContainsMocks(c) :-
  isArrayFieldThatContainsMocks(f),
  LoadInstanceField(_, f, c, _).
isArrayLocalThatContainsMocks(c) :-
  isArrayLocalThatContainsMocks(c1),
  AssignLocal(c1, c, _).
isArrayLocalThatContainsMocks(v) :-
  isInterprocArrayLocalThatContainsMocks(v).
.output isArrayLocalThatContainsMocks

// ** arrays \times fields
.decl isArrayFieldThatContainsMocks(f:Field)
// arr = _.f <- (2) propagates so that field f is a field that contains mocks
// arr[i] = mv <- (1) marks arr as an arraylocalthatcontainsmocks
#ifdef FIELDS
isArrayFieldThatContainsMocks(f) :-
  isArrayLocalThatContainsMocks(arr),
  LoadInstanceField(_, f, arr, _).
#endif
.output isArrayFieldThatContainsMocks

// ** fields
// .decl LoadInstanceField(?base:Var, ?sig:Field, ?to:Var, ?inmethod:Method)
// .decl StoreInstanceField(?from:Var, ?base:Var, ?signature:Field, ?inmethod: Method)
.decl fieldContainsMock(signature: Field)
fieldContainsMock(signature) :-
  StoreInstanceField(from, _, signature, _),
  isMockVar(from).
fieldContainsMock(signature) :-
  Field_Annotation(signature, a),
  MockFieldAnnotation(a).
.output fieldContainsMock

.output VirtualMethodInvocation_Base
.output VirtualMethodInvocation
.output ActualParam
.output AssignReturnValue
.output StoreInstanceField
.output LoadInstanceField
.output LoadArrayIndex
