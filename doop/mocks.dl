// ./doop -a context-insensitive -i ~/hacking/MockAbstraction/Benchmarks/microbenchmark/target/payroll-test-0.0.1-SNAPSHOT.jar -i ~/hacking/MockAbstraction/Benchmarks/microbenchmark/target/payroll-test-0.0.1-SNAPSHOT-tests.jar -i ~/hacking/MockAbstraction/Benchmarks/microbenchmark/mvn_dependencies/ --id context-insensitive-with-mocks --souffle-jobs 32 --define-cpp-macro USE_CALLGRAPH --main ca.liang.RootDriver --extra-logic souffle-logic/analyses/mocks/mocks.dl

// ./doop -a basic-only -i ~/hacking/MockAbstraction/Benchmarks/microbenchmark/target/payroll-test-0.0.1-SNAPSHOT.jar -i ~/hacking/MockAbstraction/Benchmarks/microbenchmark/target/payroll-test-0.0.1-SNAPSHOT-tests.jar -i ~/hacking/MockAbstraction/Benchmarks/microbenchmark/mvn_dependencies/ --id basic-only-with-mocks --souffle-jobs 32 --define-cpp-macro USE_BASIC --main ca.liang.RootDriver --extra-logic souffle-logic/analyses/mocks/mocks.dl

// these are mostly used in isMockVar, but the places where we combine two things will have specific #ifdef tests also
// use --define-cpp-macro to actually define them
// #define NO_INTERPROC 1
// #define NO_COLLECTIONS 1
// #define NO_ARRAYS 1
// #define NO_FIELDS 1

// MainClass("ca.liang.RootDriver").

// m: Method
.decl MockSourceMethod(m: Method)
MockSourceMethod("<org.easymock.EasyMock: java.lang.Object createMock(java.lang.Class)>").
MockSourceMethod("<org.mockito.Mockito: java.lang.Object mock(java.lang.Class)>").
MockSourceMethod("<org.powermock.api.mockito.PowerMockito: java.lang.Object mock(java.lang.Class)>").
MockSourceMethod("<org.mockito.Mockito: java.lang.Object verify(java.lang.Object)>").
MockSourceMethod("<org.mockito.Mockito: java.lang.Object verify(java.lang.Object,org.mockito.verification.VerificationMode)>").
MockSourceMethod("<org.mockito.internal.MockitoCore: java.lang.Object verify(java.lang.Object)>").
MockSourceMethod("<org.mockito.InOrder: java.lang.Object verify(java.lang.Object)>").
MockSourceMethod("<org.mockito.internal.InOrderImpl: java.lang.Object verify(java.lang.Object)>").
MockSourceMethod("<org.mockito.internal.MockitoCore: java.lang.Object verify(java.lang.Object,org.mockito.verification.VerificationMode)>").
MockSourceMethod("<org.mockito.InOrder: java.lang.Object verify(java.lang.Object,org.mockito.verification.VerificationMode)>").
MockSourceMethod("<org.mockito.internal.InOrderImpl: java.lang.Object verify(java.lang.Object,org.mockito.verification.VerificationMode)>").

.decl MockFieldAnnotation(a: Annotation)
MockFieldAnnotation("org.mockito.Mock").

// not handled
// stream(), parallelStream(), forEach(Consumer), spliterator()
// forEachRemaining()

// not handled yet
// Deque.clone()

.decl CollectionPutMethod(m:Method)
CollectionPutMethod("<java.util.Collection: boolean add(java.lang.Object)>").
CollectionPutMethod("<java.util.List: void add(int,java.lang.Object)>").
CollectionPutMethod("<java.util.List: java.lang.Object set(int,java.lang.Object)>").
CollectionPutMethod("<java.util.Vector: void setElementAt(java.lang.Object,int)>").
CollectionPutMethod("<java.util.Vector: void insertElementAt(java.lang.Object,int)>").
CollectionPutMethod("<java.util.Vector: void addElement(java.lang.Object)>").
CollectionPutMethod("<java.util.Queue: boolean offer(java.lang.Object)>").
CollectionPutMethod("<java.util.Deque: void addFirst(java.lang.Object)>").
CollectionPutMethod("<java.util.Deque: void addLast(java.lang.Object)>").
CollectionPutMethod("<java.util.Deque: boolean offerFirst(java.lang.Object)>").
CollectionPutMethod("<java.util.Deque: boolean offerLast(java.lang.Object)>").
CollectionPutMethod("<java.util.Deque: void push(java.lang.Object)>").
CollectionPutMethod(m) :-
  CollectionPutMethod(m0),
  basic.MethodOverridesOther(m, m0).
CollectionPutMethod(m) :-
  CollectionPutMethod(m0),
  Method_DeclaringType(m, t),
  Method_DeclaringType(m0, t0),
  SameMethodExceptDeclaringType(m, m0),
  basic.Superinterface(t0, t).

.decl CollectionAddAllMethod(m:Method)
CollectionAddAllMethod("<java.util.Collection: boolean addAll(java.util.Collection)>").
CollectionAddAllMethod("<java.util.List: boolean addAll(int,java.util.Collection)>").
CollectionAddAllMethod("<java.util.PriorityQueue: void <init>(java.util.PriorityQueue)>").
CollectionAddAllMethod("<java.util.PriorityQueue: void <init>(java.util.SortedSet)>").
CollectionAddAllMethod("<java.util.TreeSet: void <init>(java.util.SortedSet)>").
CollectionAddAllMethod(m) :-
  CollectionAddAllMethod(m0),
  basic.MethodOverridesOther(m, m0).
CollectionAddAllMethod(m) :-
  CollectionAddAllMethod(m0),
  Method_DeclaringType(m, t),
  Method_DeclaringType(m0, t0),
  SameMethodExceptDeclaringType(m, m0),
  basic.Superinterface(t0, t).
// special case for the addAll-like interface ctor
CollectionAddAllMethod(m) :-
  basic.Superinterface("java.util.Collection", t),
  Method_DeclaringType(m, t),
  Method_Descriptor(m, "void(java.util.Collection)"),
  Method_SimpleName(m, "<init>").

.decl CollectionGetMethod(m:Method)
CollectionGetMethod("<java.util.List: java.lang.Object get(int)>").
CollectionGetMethod("<java.util.Iterator: java.lang.Object next()>").
CollectionGetMethod("<java.util.ListIterator: java.lang.Object previous()>").
CollectionGetMethod("<java.util.Enumeration: java.lang.Object nextElement()>").
CollectionGetMethod("<java.util.Vector: java.lang.Object elementAt(int)>").
CollectionGetMethod("<java.util.Vector: java.lang.Object firstElement()>").
CollectionGetMethod("<java.util.Vector: java.lang.Object lastElement()>").
CollectionGetMethod("<java.util.Queue: java.lang.Object element()>").
CollectionGetMethod("<java.util.Queue: java.lang.Object remove()>").
CollectionGetMethod("<java.util.Queue: java.lang.Object peek()>").
CollectionGetMethod("<java.util.Queue: java.lang.Object poll()>").
CollectionGetMethod("<java.util.Deque: java.lang.Object removeFirst()>").
CollectionGetMethod("<java.util.Deque: java.lang.Object removeLast()>").
CollectionGetMethod("<java.util.Deque: java.lang.Object pollFirst()>").
CollectionGetMethod("<java.util.Deque: java.lang.Object pollLast()>").
CollectionGetMethod("<java.util.Deque: java.lang.Object pop()>").
CollectionGetMethod("<java.util.Deque: java.lang.Object getFirst()>").
CollectionGetMethod("<java.util.Deque: java.lang.Object getLast()>").
CollectionGetMethod("<java.util.Deque: java.lang.Object peekFirst()>").
CollectionGetMethod("<java.util.Deque: java.lang.Object peekLast()>").
CollectionGetMethod("<java.util.SortedSet: java.lang.Object first()>").
CollectionGetMethod("<java.util.SortedSet: java.lang.Object last()>").
CollectionGetMethod("<java.util.NavigableSet: java.lang.Object ceiling(java.lang.Object)>").
CollectionGetMethod("<java.util.NavigableSet: java.lang.Object floor(java.lang.Object)>").
CollectionGetMethod("<java.util.NavigableSet: java.lang.Object higher(java.lang.Object)>").
CollectionGetMethod("<java.util.NavigableSet: java.lang.Object lower(java.lang.Object)>").
CollectionGetMethod(m) :-
  CollectionGetMethod(m0),
  basic.MethodOverridesOther(m, m0).
CollectionGetMethod(m) :-
  CollectionGetMethod(m0),
  Method_DeclaringType(m, t),
  Method_DeclaringType(m0, t0),
  SameMethodExceptDeclaringType(m, m0),
  basic.Superinterface(t0, t).

.decl CollectionIteratorMethod(m:Method)
CollectionIteratorMethod("<java.util.Iterable: java.util.Iterator iterator()>").
CollectionIteratorMethod("<java.util.Collection: java.util.Iterator iterator()>").
CollectionIteratorMethod("<java.util.Deque: java.util.Iterator descendingIterator()>").
CollectionIteratorMethod("<java.util.NavigableSet: java.util.NavigableSet descendingSet()>").
CollectionIteratorMethod("<java.util.List: java.util.ListIterator listIterator()>").
CollectionIteratorMethod("<java.util.List: java.util.ListIterator listIterator(int)>").
CollectionIteratorMethod("<java.util.List: java.util.List subList(int,int)>").
CollectionIteratorMethod("<java.util.Vector: java.util.Enumeration elements()>").
CollectionIteratorMethod("<java.util.SortedSet: java.util.SortedSet headSet(java.lang.Object)>").
CollectionIteratorMethod("<java.util.NavigableSet: java.util.NavigableSet headSet(java.lang.Object,boolean)>").
CollectionIteratorMethod("<java.util.SortedSet: java.util.SortedSet tailSet(java.lang.Object)>").
CollectionIteratorMethod("<java.util.NavigableSet: java.util.NavigableSet tailSet(java.lang.Object,boolean)>").
CollectionIteratorMethod("<java.util.NavigableSet: java.util.NavigableSet subSet(java.lang.Object,boolean,java.lang.Object,boolean)>").
CollectionIteratorMethod("<java.util.NavigableSet: java.util.SortedSet subSet(java.lang.Object,java.lang.Object)>").
CollectionIteratorMethod(m) :-
  CollectionIteratorMethod(m0),
  basic.MethodOverridesOther(m, m0).
CollectionIteratorMethod(m) :-
  CollectionIteratorMethod(m0),
  Method_DeclaringType(m, t),
  Method_DeclaringType(m0, t0),
  SameMethodExceptDeclaringType(m, m0),
  basic.Superinterface(t0, t).

.decl CollectionCopyIntoMethod(m:Method)
CollectionCopyIntoMethod("<java.util.Vector: void copyInto(java.lang.Object[])>").

.decl CollectionToArrayMethod(m:Method)
CollectionToArrayMethod("<java.util.Collection: java.lang.Object[] toArray()>").
CollectionToArrayMethod("<java.util.Collection: java.lang.Object[] toArray(java.lang.Object[])>").
CollectionToArrayMethod(m) :-
  CollectionToArrayMethod(m0),
  basic.MethodOverridesOther(m, m0).
CollectionToArrayMethod(m) :-
  CollectionToArrayMethod(m0),
  Method_DeclaringType(m, t),
  Method_DeclaringType(m0, t0),
  SameMethodExceptDeclaringType(m, m0),
  basic.Superinterface(t0, t).

.decl SameMethodExceptDeclaringType(m:Method, m0:Method)
SameMethodExceptDeclaringType(m, m0) :-
  Method_SimpleName(m, n),
  Method_SimpleName(m0, n),
  Method_Descriptor(m, d),
  Method_Descriptor(m0, d).

#ifdef USE_BASIC
.decl CallGraphEdge(s:number, mi:MethodInvocation, t:number, ms:Method)
CallGraphEdge(0, mi, 0, ms) :-
  basic.ResolveInvocation(rv, mi, ms),
  basic.VirtualMethodInvocation_BaseType(mi, rv).
CallGraphEdge(0, mi, 0, ms) :-
  MethodInvocation_Method(mi, ms).
#endif

#ifdef USE_CALLGRAPH
.decl CallGraphEdge(callerCtx:symbol, mi:MethodInvocation, calleeCtx:symbol, ms:Method)
CallGraphEdge(callerCtx, mi, calleeCtx, ms) :-
  mainAnalysis.CallGraphEdge(callerCtx, mi, calleeCtx, ms).
#endif

.decl callsMockSource(mi: MethodInvocation)
callsMockSource(mi) :-
  MockSourceMethod(ms),
  CallGraphEdge(_, mi, _, ms).
.output callsMockSource

// v:Var
.decl isMockVar(v: Var)
isMockVar(v) :-
  AssignReturnValue(mi, v),
  callsMockSource(mi).
isMockVar(v) :-
  isMockVar(from),
  AssignCast(_ /* type */, from, v, _ /* inmethod */).
isMockVar(v) :-
  isMockVar(v1),
  AssignLocal(v1, v, _).
#ifndef NO_INTERPROC
isMockVar(v) :-
  isInterprocMockVar(v).
#endif
#ifndef NO_FIELDS
isMockVar(v) :-
  LoadInstanceField(_, field, v, _),
  fieldContainsMock(field).
#endif
#ifndef NO_COLLECTIONS
isMockVar(v) :-
// v = c.get(_);
  isCollectionLocalThatContainsMocks(c, _),
  CollectionGetMethod(get),
  VirtualMethodInvocation(mi, get, _),
  VirtualMethodInvocation_Base(mi, c),
  AssignReturnValue(mi, v).
#endif
#ifndef NO_ARRAYS
isMockVar(v) :-
// v = c[_];
  isArrayLocalThatContainsMocks(c),
  LoadArrayIndex(c, v, _).
#endif
.output isMockVar

.decl isMockInvocation(mi: MethodInvocation, signature:Method, inMethod:Method, line: number, receiver: symbol)
isMockInvocation(mi, signature, inmethod, line, receiver) :-
  _MethodInvocation_Line(mi, line),
  VirtualMethodInvocation(mi, signature, inmethod),
  VirtualMethodInvocation_Base(mi, receiver),
  isMockVar(receiver).
.output isMockInvocation

// ** interprocedural
.decl isInterprocMockVar(v:Var)
// propagate back to caller in m = returnsMock()
isInterprocMockVar(v) :-
  AssignReturnValue(mi, v),
  CallGraphEdge(_, mi, _, callee),
  ReturnVar(v_callee, callee),
  isMockVar(v_callee).

// propagate to callee in callSomething(mock)
isInterprocMockVar(v_callee) :-
  isMockVar(v),
  ActualParam(n, mi, v),
  FormalParam(n, callee, v_callee),
  CallGraphEdge(_, mi, _, callee),
  Method_DeclaringType(callee, callee_class),
  ApplicationClass(callee_class).
.output isInterprocMockVar

// ** collections
.decl isCollectionLocalThatContainsMocks(c:Var, inmethod:Method)
// c.add(mv)
isCollectionLocalThatContainsMocks(c, inmethod) :-
  CollectionPutMethod(put),
  VirtualMethodInvocation(mi, put, inmethod),
  VirtualMethodInvocation_Base(mi, c),
  ActualParam(_, mi, mv),
  isMockVar(mv).
// c = _.f
isCollectionLocalThatContainsMocks(c, inmethod) :-
  isCollectionFieldThatContainsMocks(f),
  LoadInstanceField(_, f, c, inmethod).
// c1 = c
isCollectionLocalThatContainsMocks(c, inmethod) :-
  isCollectionLocalThatContainsMocks(c1, inmethod),
  AssignLocal(c1, c, inmethod).
// c.addAll(c1)
isCollectionLocalThatContainsMocks(c, inmethod) :-
  isCollectionLocalThatContainsMocks(c1, inmethod),
  CollectionAddAllMethod(add_all),
  VirtualMethodInvocation(mi, add_all, inmethod),
  VirtualMethodInvocation_Base(mi, c),
  ActualParam(_, mi, c1).
// c = new Collection(c1) [actually c.<init>(c1)]
isCollectionLocalThatContainsMocks(c, inmethod) :-
  isCollectionLocalThatContainsMocks(c1, inmethod),
  CollectionAddAllMethod(add_all),
  MethodInvocation_Method(mi, add_all),
  Instruction_Method(mi, inmethod),
  SpecialMethodInvocation_Base(mi, c),
  ActualParam(_, mi, c1).
// it = c.iterator()
isCollectionLocalThatContainsMocks(it, inmethod) :-
  isCollectionLocalThatContainsMocks(c, inmethod),
  CollectionIteratorMethod(it_method),
  VirtualMethodInvocation(mi, it_method, inmethod),
  VirtualMethodInvocation_Base(mi, c),
  AssignReturnValue(mi, it).

.output isCollectionLocalThatContainsMocks

// ** collections \times fields
.decl isCollectionFieldThatContainsMocks(f:Field)
// base.f = c where c is a CollectionLocalThatContainsMocks -> f is a field that contains mocks
#ifndef NO_FIELDS
isCollectionFieldThatContainsMocks(f) :-
  isCollectionLocalThatContainsMocks(c, _),
  StoreInstanceField(c, _, f, _).
// c = base.f where c is a CollectionLocalThatContainsMocks (since we're flow-insensitive)
isCollectionFieldThatContainsMocks(f) :-
  isCollectionLocalThatContainsMocks(c, _),
  LoadInstanceField(_ /*base*/, f, c, _ /*inmethod*/).
#endif
.output isCollectionFieldThatContainsMocks

// ** arrays
.decl isInterprocArrayLocalThatContainsMocks(c:Var)
#ifndef NO_INTERPROC
isInterprocArrayLocalThatContainsMocks(v) :-
  AssignReturnValue(mi, v),
  CallGraphEdge(_, mi, _, callee),
  ReturnVar(v_callee, callee),
  isArrayLocalThatContainsMocks(v_callee).
#endif
.output isInterprocArrayLocalThatContainsMocks

.decl isArrayLocalThatContainsMocks(c:Var)
// c[idx] = mv @ insn
isArrayLocalThatContainsMocks(c) :-
  StoreArrayIndex(mv, c, _),
  isMockVar(mv).
// c = _.f, f contains mocks
isArrayLocalThatContainsMocks(c) :-
  isArrayFieldThatContainsMocks(f),
  LoadInstanceField(_, f, c, _).
// c = c1, c1 contains mocks
isArrayLocalThatContainsMocks(c) :-
  isArrayLocalThatContainsMocks(c1),
  AssignLocal(c1, c, _).
// c = (Type) c1, c1 contains mocks
isArrayLocalThatContainsMocks(c) :-
  isArrayLocalThatContainsMocks(c1),
  AssignCast(_, c1, c, _).

// ** collections \times arrays
// c.copyInto(array)
#ifndef NO_COLLECTIONS
isArrayLocalThatContainsMocks(array) :-
  isCollectionLocalThatContainsMocks(c, inmethod),
  CollectionCopyIntoMethod(copy_into),
  VirtualMethodInvocation(mi, copy_into, inmethod),
  VirtualMethodInvocation_Base(mi, c),
  ActualParam(0, mi, array).
// a = c.toArray(*)
isArrayLocalThatContainsMocks(array) :-
  isCollectionLocalThatContainsMocks(c, inmethod),
  CollectionToArrayMethod(toarray),
  VirtualMethodInvocation(mi, toarray, inmethod),
  VirtualMethodInvocation_Base(mi, c),
  AssignReturnValue(mi, array).
#endif

isArrayLocalThatContainsMocks(v) :-
  isInterprocArrayLocalThatContainsMocks(v).
.output isArrayLocalThatContainsMocks

// ** arrays \times fields
.decl isArrayFieldThatContainsMocks(f:Field)
// arr = _.f <- (2) propagates so that field f is a field that contains mocks
// arr[i] = mv <- (1) marks arr as an arraylocalthatcontainsmocks
#ifndef NO_FIELDS
isArrayFieldThatContainsMocks(f) :-
  isArrayLocalThatContainsMocks(arr),
  LoadInstanceField(_, f, arr, _).
#endif
.output isArrayFieldThatContainsMocks

// ** fields
// .decl LoadInstanceField(?base:Var, ?sig:Field, ?to:Var, ?inmethod:Method)
// .decl StoreInstanceField(?from:Var, ?base:Var, ?signature:Field, ?inmethod: Method)
.decl fieldContainsMock(signature: Field)
fieldContainsMock(signature) :-
  StoreInstanceField(from, _, signature, _),
  isMockVar(from).
fieldContainsMock(signature) :-
  Field_Annotation(signature, a),
  MockFieldAnnotation(a).
.output fieldContainsMock

.output VirtualMethodInvocation_Base
.output VirtualMethodInvocation
.output ActualParam
.output AssignReturnValue
.output StoreInstanceField
.output LoadInstanceField
.output LoadArrayIndex

.output CollectionAddAllMethod
.output MethodInvocation_Method
.output Instruction_Method
.output SpecialMethodInvocation_Base
.output ActualParam
.output CollectionGetMethod
.output CollectionIteratorMethod
