<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DailyTimeIntervalTriggerImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">quartz-core</a> &gt; <a href="index.source.html" class="el_package">org.quartz.impl.triggers</a> &gt; <span class="el_source">DailyTimeIntervalTriggerImpl.java</span></div><h1>DailyTimeIntervalTriggerImpl.java</h1><pre class="source lang-java linenums">/* 
 * All content copyright Terracotta, Inc., unless otherwise indicated. All rights reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not 
 * use this file except in compliance with the License. You may obtain a copy 
 * of the License at 
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0 
 *   
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT 
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
 * License for the specific language governing permissions and limitations 
 * under the License.
 * 
 */
package org.quartz.impl.triggers;

import java.util.Calendar;
import java.util.Date;
import java.util.Set;

import org.quartz.DailyTimeIntervalScheduleBuilder;
import org.quartz.DailyTimeIntervalTrigger;
import org.quartz.DateBuilder;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.quartz.ScheduleBuilder;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.TimeOfDay;
import org.quartz.Trigger;
import org.quartz.DateBuilder.IntervalUnit;

/**
 * A concrete implementation of DailyTimeIntervalTrigger that is used to fire a &lt;code&gt;{@link org.quartz.JobDetail}&lt;/code&gt;
 * based upon daily repeating time intervals.
 * 
 * &lt;p&gt;The trigger will fire every N (see {@link #setRepeatInterval(int)} ) seconds, minutes or hours
 * (see {@link #setRepeatIntervalUnit(org.quartz.DateBuilder.IntervalUnit)}) during a given time window on specified days of the week.&lt;/p&gt;
 * 
 * &lt;p&gt;For example#1, a trigger can be set to fire every 72 minutes between 8:00 and 11:00 everyday. It's fire times would 
 * be 8:00, 9:12, 10:24, then next day would repeat: 8:00, 9:12, 10:24 again.&lt;/p&gt;
 * 
 * &lt;p&gt;For example#2, a trigger can be set to fire every 23 minutes between 9:20 and 16:47 Monday through Friday.&lt;/p&gt;
 * 
 * &lt;p&gt;On each day, the starting fire time is reset to startTimeOfDay value, and then it will add repeatInterval value to it until
 * the endTimeOfDay is reached. If you set daysOfWeek values, then fire time will only occur during those week days period. Again,
 * remember this trigger will reset fire time each day with startTimeOfDay, regardless of your interval or endTimeOfDay!&lt;/p&gt; 
 * 
 * &lt;p&gt;The default values for fields if not set are: startTimeOfDay defaults to 00:00:00, the endTimeOfDay default to 23:59:59, 
 * and daysOfWeek is default to every day. The startTime default to current time-stamp now, while endTime has not value.&lt;/p&gt;
 * 
 * &lt;p&gt;If startTime is before startTimeOfDay, then startTimeOfDay will be used and startTime has no affect other than to specify
 * the first day of firing. Else if startTime is 
 * after startTimeOfDay, then the first fire time for that day will be the next interval after the startTime. For example, if
 * you set startingTimeOfDay=9am, endingTimeOfDay=11am, interval=15 mins, and startTime=9:33am, then the next fire time will
 * be 9:45pm. Note also that if you do not set startTime value, the trigger builder will default to current time, and current time 
 * maybe before or after the startTimeOfDay! So be aware how you set your startTime.&lt;/p&gt;
 * 
 * &lt;p&gt;This trigger also supports &quot;repeatCount&quot; feature to end the trigger fire time after
 * a certain number of count is reached. Just as the SimpleTrigger, setting repeatCount=0 
 * means trigger will fire once only! Setting any positive count then the trigger will repeat 
 * count + 1 times. Unlike SimpleTrigger, the default value of repeatCount of this trigger
 * is set to REPEAT_INDEFINITELY instead of 0 though.
 * 
 * @see DailyTimeIntervalTrigger
 * @see DailyTimeIntervalScheduleBuilder
 * 
 * @since 2.1.0
 * 
 * @author James House
 * @author Zemian Deng &lt;saltnlight5@gmail.com&gt;
 */
public class DailyTimeIntervalTriggerImpl extends AbstractTrigger&lt;DailyTimeIntervalTrigger&gt; implements DailyTimeIntervalTrigger, CoreTrigger {
    
    private static final long serialVersionUID = -632667786771388749L;
    
    /*
     * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     * 
     * Constants.
     * 
     * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     */
<span class="fc" id="L86">    private static final int YEAR_TO_GIVEUP_SCHEDULING_AT = java.util.Calendar.getInstance().get(java.util.Calendar.YEAR) + 100;</span>

    /*
     * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     * 
     * Data members.
     * 
     * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     */
    
<span class="fc" id="L96">    private Date startTime = null;</span>

<span class="fc" id="L98">    private Date endTime = null;</span>

<span class="fc" id="L100">    private Date nextFireTime = null;</span>

<span class="fc" id="L102">    private Date previousFireTime = null;</span>
    
<span class="fc" id="L104">    private int repeatCount = REPEAT_INDEFINITELY;</span>

<span class="fc" id="L106">    private  int repeatInterval = 1;</span>
    
<span class="fc" id="L108">    private IntervalUnit repeatIntervalUnit = IntervalUnit.MINUTE;</span>

    private Set&lt;Integer&gt; daysOfWeek;
    
    private TimeOfDay startTimeOfDay;

    private TimeOfDay endTimeOfDay;
    
<span class="fc" id="L116">    private int timesTriggered = 0;</span>

<span class="fc" id="L118">    private boolean complete = false;</span>

    /*
     * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     * 
     * Constructors.
     * 
     * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     */

    /**
     * &lt;p&gt;
     * Create a &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; with no settings.
     * &lt;/p&gt;
     */
    public DailyTimeIntervalTriggerImpl() {
<span class="fc" id="L134">        super();</span>
<span class="fc" id="L135">    }</span>

    /**
     * &lt;p&gt;
     * Create a &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; that will occur immediately, and
     * repeat at the the given interval.
     * &lt;/p&gt;
     * 
     * @param startTimeOfDay 
     *          The &lt;code&gt;TimeOfDay&lt;/code&gt; that the repeating should begin occurring.          
     * @param endTimeOfDay 
     *          The &lt;code&gt;TimeOfDay&lt;/code&gt; that the repeating should stop occurring.          
     * @param intervalUnit The repeat interval unit. The only intervals that are valid for this type of trigger are 
     * {@link IntervalUnit#SECOND}, {@link IntervalUnit#MINUTE}, and {@link IntervalUnit#HOUR}.
     * @throws IllegalArgumentException if an invalid IntervalUnit is given, or the repeat interval is zero or less.
     */
    public DailyTimeIntervalTriggerImpl(String name, TimeOfDay startTimeOfDay, TimeOfDay endTimeOfDay, IntervalUnit intervalUnit,  int repeatInterval) {
<span class="nc" id="L152">        this(name, null, startTimeOfDay, endTimeOfDay, intervalUnit, repeatInterval);</span>
<span class="nc" id="L153">    }</span>

    /**
     * &lt;p&gt;
     * Create a &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; that will occur immediately, and
     * repeat at the the given interval.
     * &lt;/p&gt;
     * 
     * @param startTimeOfDay 
     *          The &lt;code&gt;TimeOfDay&lt;/code&gt; that the repeating should begin occurring.          
     * @param endTimeOfDay 
     *          The &lt;code&gt;TimeOfDay&lt;/code&gt; that the repeating should stop occurring.          
     * @param intervalUnit The repeat interval unit. The only intervals that are valid for this type of trigger are 
     * {@link IntervalUnit#SECOND}, {@link IntervalUnit#MINUTE}, and {@link IntervalUnit#HOUR}.
     * @throws IllegalArgumentException if an invalid IntervalUnit is given, or the repeat interval is zero or less.
     */
    public DailyTimeIntervalTriggerImpl(String name, String group, TimeOfDay startTimeOfDay, 
            TimeOfDay endTimeOfDay, IntervalUnit intervalUnit, int repeatInterval) {
<span class="nc" id="L171">        this(name, group, new Date(), null, startTimeOfDay, endTimeOfDay, intervalUnit, repeatInterval);</span>
<span class="nc" id="L172">    }</span>
    
    /**
     * &lt;p&gt;
     * Create a &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; that will occur at the given time,
     * and repeat at the the given interval until the given end time.
     * &lt;/p&gt;
     * 
     * @param startTime
     *          A &lt;code&gt;Date&lt;/code&gt; set to the time for the &lt;code&gt;Trigger&lt;/code&gt;
     *          to fire.
     * @param endTime
     *          A &lt;code&gt;Date&lt;/code&gt; set to the time for the &lt;code&gt;Trigger&lt;/code&gt;
     *          to quit repeat firing.
     * @param startTimeOfDay 
     *          The &lt;code&gt;TimeOfDay&lt;/code&gt; that the repeating should begin occurring.          
     * @param endTimeOfDay 
     *          The &lt;code&gt;TimeOfDay&lt;/code&gt; that the repeating should stop occurring.          
     * @param intervalUnit The repeat interval unit. The only intervals that are valid for this type of trigger are
     * {@link IntervalUnit#SECOND}, {@link IntervalUnit#MINUTE}, and {@link IntervalUnit#HOUR}.
     * @param repeatInterval
     *          The number of milliseconds to pause between the repeat firing.
     * @throws IllegalArgumentException if an invalid IntervalUnit is given, or the repeat interval is zero or less.
     */
    public DailyTimeIntervalTriggerImpl(String name, Date startTime,
            Date endTime, TimeOfDay startTimeOfDay, TimeOfDay endTimeOfDay, 
            IntervalUnit intervalUnit,  int repeatInterval) {
<span class="nc" id="L199">        this(name, null, startTime, endTime, startTimeOfDay, endTimeOfDay, intervalUnit, repeatInterval);</span>
<span class="nc" id="L200">    }</span>
    
    /**
     * &lt;p&gt;
     * Create a &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; that will occur at the given time,
     * and repeat at the the given interval until the given end time.
     * &lt;/p&gt;
     * 
     * @param startTime
     *          A &lt;code&gt;Date&lt;/code&gt; set to the time for the &lt;code&gt;Trigger&lt;/code&gt;
     *          to fire.
     * @param endTime
     *          A &lt;code&gt;Date&lt;/code&gt; set to the time for the &lt;code&gt;Trigger&lt;/code&gt;
     *          to quit repeat firing.
     * @param startTimeOfDay 
     *          The &lt;code&gt;TimeOfDay&lt;/code&gt; that the repeating should begin occurring.          
     * @param endTimeOfDay 
     *          The &lt;code&gt;TimeOfDay&lt;/code&gt; that the repeating should stop occurring.          
     * @param intervalUnit The repeat interval unit. The only intervals that are valid for this type of trigger are 
     * {@link IntervalUnit#SECOND}, {@link IntervalUnit#MINUTE}, and {@link IntervalUnit#HOUR}.
     * @param repeatInterval
     *          The number of milliseconds to pause between the repeat firing.
     * @throws IllegalArgumentException if an invalid IntervalUnit is given, or the repeat interval is zero or less.
     */
    public DailyTimeIntervalTriggerImpl(String name, String group, Date startTime,
            Date endTime, TimeOfDay startTimeOfDay, TimeOfDay endTimeOfDay, 
            IntervalUnit intervalUnit,  int repeatInterval) {
<span class="fc" id="L227">        super(name, group);</span>

<span class="fc" id="L229">        setStartTime(startTime);</span>
<span class="fc" id="L230">        setEndTime(endTime);</span>
<span class="fc" id="L231">        setRepeatIntervalUnit(intervalUnit);</span>
<span class="fc" id="L232">        setRepeatInterval(repeatInterval);</span>
<span class="fc" id="L233">        setStartTimeOfDay(startTimeOfDay);</span>
<span class="fc" id="L234">        setEndTimeOfDay(endTimeOfDay);</span>
<span class="fc" id="L235">    }</span>

    /**
     * &lt;p&gt;
     * Create a &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; that will occur at the given time,
     * fire the identified &lt;code&gt;Job&lt;/code&gt; and repeat at the the given
     * interval until the given end time.
     * &lt;/p&gt;
     * 
     * @param startTime
     *          A &lt;code&gt;Date&lt;/code&gt; set to the time for the &lt;code&gt;Trigger&lt;/code&gt;
     *          to fire.
     * @param endTime
     *          A &lt;code&gt;Date&lt;/code&gt; set to the time for the &lt;code&gt;Trigger&lt;/code&gt;
     *          to quit repeat firing.
     * @param startTimeOfDay 
     *          The &lt;code&gt;TimeOfDay&lt;/code&gt; that the repeating should begin occurring.          
     * @param endTimeOfDay 
     *          The &lt;code&gt;TimeOfDay&lt;/code&gt; that the repeating should stop occurring.          
     * @param intervalUnit The repeat interval unit. The only intervals that are valid for this type of trigger are 
     * {@link IntervalUnit#SECOND}, {@link IntervalUnit#MINUTE}, and {@link IntervalUnit#HOUR}.
     * @param repeatInterval
     *          The number of milliseconds to pause between the repeat firing.
     * @throws IllegalArgumentException if an invalid IntervalUnit is given, or the repeat interval is zero or less.
     */
    public DailyTimeIntervalTriggerImpl(String name, String group, String jobName,
            String jobGroup, Date startTime, Date endTime, 
            TimeOfDay startTimeOfDay, TimeOfDay endTimeOfDay,
            IntervalUnit intervalUnit,  int repeatInterval) {
<span class="fc" id="L264">        super(name, group, jobName, jobGroup);</span>

<span class="fc" id="L266">        setStartTime(startTime);</span>
<span class="fc" id="L267">        setEndTime(endTime);</span>
<span class="fc" id="L268">        setRepeatIntervalUnit(intervalUnit);</span>
<span class="fc" id="L269">        setRepeatInterval(repeatInterval);</span>
<span class="fc" id="L270">        setStartTimeOfDay(startTimeOfDay);</span>
<span class="fc" id="L271">        setEndTimeOfDay(endTimeOfDay);</span>
<span class="fc" id="L272">    }</span>

    /*
     * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     * 
     * Interface.
     * 
     * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     */

    /**
     * &lt;p&gt;
     * Get the time at which the &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; should occur. It defaults to 
     * the getStartTimeOfDay of current day.
     * &lt;/p&gt;
     */
    @Override
    public Date getStartTime() {
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">        if(startTime == null) {</span>
<span class="nc" id="L291">            startTime = new Date();</span>
        }
<span class="fc" id="L293">        return startTime;</span>
    }

    /**
     * &lt;p&gt;
     * Set the time at which the &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; should occur.
     * &lt;/p&gt;
     * 
     * @exception IllegalArgumentException
     *              if startTime is &lt;code&gt;null&lt;/code&gt;.
     */
    @Override
    public void setStartTime(Date startTime) {
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        if (startTime == null) {</span>
<span class="nc" id="L307">            throw new IllegalArgumentException(&quot;Start time cannot be null&quot;);</span>
        }

<span class="fc" id="L310">        Date eTime = getEndTime();</span>
<span class="pc bpc" id="L311" title="3 of 4 branches missed.">        if (eTime != null &amp;&amp; eTime.before(startTime)) {</span>
<span class="nc" id="L312">            throw new IllegalArgumentException(</span>
                &quot;End time cannot be before start time&quot;);    
        }

<span class="fc" id="L316">        this.startTime = startTime;</span>
<span class="fc" id="L317">    }</span>

    /**
     * &lt;p&gt;
     * Get the time at which the &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; should quit
     * repeating.
     * &lt;/p&gt;
     * 
     * @see #getFinalFireTime()
     */
    @Override
    public Date getEndTime() {
<span class="fc" id="L329">        return endTime;</span>
    }

    /**
     * &lt;p&gt;
     * Set the time at which the &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; should quit
     * repeating (and be automatically deleted).
     * &lt;/p&gt;
     * 
     * @exception IllegalArgumentException
     *              if endTime is before start time.
     */
    @Override
    public void setEndTime(Date endTime) {
<span class="fc" id="L343">        Date sTime = getStartTime();</span>
<span class="pc bpc" id="L344" title="2 of 6 branches missed.">        if (sTime != null &amp;&amp; endTime != null &amp;&amp; sTime.after(endTime)) {</span>
<span class="nc" id="L345">            throw new IllegalArgumentException(</span>
                    &quot;End time cannot be before start time&quot;);
        }

<span class="fc" id="L349">        this.endTime = endTime;</span>
<span class="fc" id="L350">    }</span>

    /* (non-Javadoc)
     * @see org.quartz.DailyTimeIntervalTriggerI#getRepeatIntervalUnit()
     */
    public IntervalUnit getRepeatIntervalUnit() {
<span class="fc" id="L356">        return repeatIntervalUnit;</span>
    }

    /**
     * &lt;p&gt;Set the interval unit - the time unit on with the interval applies.&lt;/p&gt;
     * 
     * @param intervalUnit The repeat interval unit. The only intervals that are valid for this type of trigger are 
     * {@link IntervalUnit#SECOND}, {@link IntervalUnit#MINUTE}, and {@link IntervalUnit#HOUR}.
     */
    public void setRepeatIntervalUnit(IntervalUnit intervalUnit) {
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">        if (repeatIntervalUnit == null || </span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">                !((repeatIntervalUnit.equals(IntervalUnit.SECOND) || </span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">                repeatIntervalUnit.equals(IntervalUnit.MINUTE) || </span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">                repeatIntervalUnit.equals(IntervalUnit.HOUR))))</span>
<span class="fc" id="L370">            throw new IllegalArgumentException(&quot;Invalid repeat IntervalUnit (must be SECOND, MINUTE or HOUR).&quot;);</span>
<span class="fc" id="L371">        this.repeatIntervalUnit = intervalUnit;</span>
<span class="fc" id="L372">    }</span>

    /* (non-Javadoc)
     * @see org.quartz.DailyTimeIntervalTriggerI#getRepeatInterval()
     */
    public int getRepeatInterval() {
<span class="fc" id="L378">        return repeatInterval;</span>
    }

    /**
     * &lt;p&gt;
     * set the the time interval that will be added to the &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt;'s
     * fire time (in the set repeat interval unit) in order to calculate the time of the 
     * next trigger repeat.
     * &lt;/p&gt;
     * 
     * @exception IllegalArgumentException
     *              if repeatInterval is &lt; 1
     */
    public void setRepeatInterval( int repeatInterval) {
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        if (repeatInterval &lt; 0) {</span>
<span class="nc" id="L393">            throw new IllegalArgumentException(</span>
                    &quot;Repeat interval must be &gt;= 1&quot;);
        }

<span class="fc" id="L397">        this.repeatInterval = repeatInterval;</span>
<span class="fc" id="L398">    }</span>

    /* (non-Javadoc)
     * @see org.quartz.DailyTimeIntervalTriggerI#getTimesTriggered()
     */
    public int getTimesTriggered() {
<span class="nc" id="L404">        return timesTriggered;</span>
    }

    /**
     * &lt;p&gt;
     * Set the number of times the &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; has already
     * fired.
     * &lt;/p&gt;
     */
    public void setTimesTriggered(int timesTriggered) {
<span class="nc" id="L414">        this.timesTriggered = timesTriggered;</span>
<span class="nc" id="L415">    }</span>

    @Override
    protected boolean validateMisfireInstruction(int misfireInstruction) {
<span class="pc bpc" id="L419" title="2 of 4 branches missed.">        return misfireInstruction &gt;= MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY &amp;&amp; misfireInstruction &lt;= MISFIRE_INSTRUCTION_DO_NOTHING;</span>

    }


    /**
     * &lt;p&gt;
     * Updates the &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt;'s state based on the
     * MISFIRE_INSTRUCTION_XXX that was selected when the &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt;
     * was created.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If the misfire instruction is set to MISFIRE_INSTRUCTION_SMART_POLICY,
     * then the following scheme will be used: &lt;br&gt;
     * &lt;ul&gt;
     * &lt;li&gt;The instruction will be interpreted as &lt;code&gt;MISFIRE_INSTRUCTION_FIRE_ONCE_NOW&lt;/code&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     */
    @Override
    public void updateAfterMisfire(org.quartz.Calendar cal) {
<span class="nc" id="L441">        int instr = getMisfireInstruction();</span>

<span class="nc bnc" id="L443" title="All 2 branches missed.">        if(instr == Trigger.MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY)</span>
<span class="nc" id="L444">            return;</span>

<span class="nc bnc" id="L446" title="All 2 branches missed.">        if (instr == MISFIRE_INSTRUCTION_SMART_POLICY) {</span>
<span class="nc" id="L447">            instr = MISFIRE_INSTRUCTION_FIRE_ONCE_NOW;</span>
        }

<span class="nc bnc" id="L450" title="All 2 branches missed.">        if (instr == MISFIRE_INSTRUCTION_DO_NOTHING) {</span>
<span class="nc" id="L451">            Date newFireTime = getFireTimeAfter(new Date());</span>
<span class="nc bnc" id="L452" title="All 4 branches missed.">            while (newFireTime != null &amp;&amp; cal != null</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">                    &amp;&amp; !cal.isTimeIncluded(newFireTime.getTime())) {</span>
<span class="nc" id="L454">                newFireTime = getFireTimeAfter(newFireTime);</span>
            }
<span class="nc" id="L456">            setNextFireTime(newFireTime);</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">        } else if (instr == MISFIRE_INSTRUCTION_FIRE_ONCE_NOW) { </span>
            // fire once now...
<span class="nc" id="L459">            setNextFireTime(new Date());</span>
            // the new fire time afterward will magically preserve the original  
            // time of day for firing for day/week/month interval triggers, 
            // because of the way getFireTimeAfter() works - in its always restarting
            // computation from the start time.
        }
<span class="nc" id="L465">    }</span>

    /**
     * &lt;p&gt;
     * Called when the &lt;code&gt;{@link Scheduler}&lt;/code&gt; has decided to 'fire'
     * the trigger (execute the associated &lt;code&gt;Job&lt;/code&gt;), in order to
     * give the &lt;code&gt;Trigger&lt;/code&gt; a chance to update itself for its next
     * triggering (if any).
     * &lt;/p&gt;
     * 
     * @see #executionComplete(JobExecutionContext, JobExecutionException)
     */
    @Override
    public void triggered(org.quartz.Calendar calendar) {
<span class="fc" id="L479">        timesTriggered++;</span>
<span class="fc" id="L480">        previousFireTime = nextFireTime;</span>
<span class="fc" id="L481">        nextFireTime = getFireTimeAfter(nextFireTime);</span>

<span class="fc bfc" id="L483" title="All 4 branches covered.">        while (nextFireTime != null &amp;&amp; calendar != null</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">                &amp;&amp; !calendar.isTimeIncluded(nextFireTime.getTime())) {</span>
            
<span class="fc" id="L486">            nextFireTime = getFireTimeAfter(nextFireTime);</span>

<span class="pc bpc" id="L488" title="1 of 2 branches missed.">            if(nextFireTime == null)</span>
<span class="nc" id="L489">                break;</span>
            
            //avoid infinite loop
<span class="fc" id="L492">            java.util.Calendar c = java.util.Calendar.getInstance();</span>
<span class="fc" id="L493">            c.setTime(nextFireTime);</span>
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">            if (c.get(java.util.Calendar.YEAR) &gt; YEAR_TO_GIVEUP_SCHEDULING_AT) {</span>
<span class="nc" id="L495">                nextFireTime = null;</span>
            }
<span class="fc" id="L497">        }</span>
        
<span class="fc bfc" id="L499" title="All 2 branches covered.">        if (nextFireTime == null) {</span>
<span class="fc" id="L500">            complete = true;</span>
        }
<span class="fc" id="L502">    }</span>


    /**
     * @see org.quartz.impl.triggers.AbstractTrigger#updateWithNewCalendar(org.quartz.Calendar, long)
     */
    @Override
    public void updateWithNewCalendar(org.quartz.Calendar calendar, long misfireThreshold)
    {
<span class="nc" id="L511">        nextFireTime = getFireTimeAfter(previousFireTime);</span>

<span class="nc bnc" id="L513" title="All 4 branches missed.">        if (nextFireTime == null || calendar == null) {</span>
<span class="nc" id="L514">            return;</span>
        }
        
<span class="nc" id="L517">        Date now = new Date();</span>
<span class="nc bnc" id="L518" title="All 4 branches missed.">        while (nextFireTime != null &amp;&amp; !calendar.isTimeIncluded(nextFireTime.getTime())) {</span>

<span class="nc" id="L520">            nextFireTime = getFireTimeAfter(nextFireTime);</span>

<span class="nc bnc" id="L522" title="All 2 branches missed.">            if(nextFireTime == null)</span>
<span class="nc" id="L523">                break;</span>
            
            //avoid infinite loop
<span class="nc" id="L526">            java.util.Calendar c = java.util.Calendar.getInstance();</span>
<span class="nc" id="L527">            c.setTime(nextFireTime);</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">            if (c.get(java.util.Calendar.YEAR) &gt; YEAR_TO_GIVEUP_SCHEDULING_AT) {</span>
<span class="nc" id="L529">                nextFireTime = null;</span>
            }

<span class="nc bnc" id="L532" title="All 4 branches missed.">            if(nextFireTime != null &amp;&amp; nextFireTime.before(now)) {</span>
<span class="nc" id="L533">                long diff = now.getTime() - nextFireTime.getTime();</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">                if(diff &gt;= misfireThreshold) {</span>
<span class="nc" id="L535">                    nextFireTime = getFireTimeAfter(nextFireTime);</span>
                }
            }
<span class="nc" id="L538">        }</span>
<span class="nc" id="L539">    }</span>

    /**
     * &lt;p&gt;
     * Called by the scheduler at the time a &lt;code&gt;Trigger&lt;/code&gt; is first
     * added to the scheduler, in order to have the &lt;code&gt;Trigger&lt;/code&gt;
     * compute its first fire time, based on any associated calendar.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * After this method has been called, &lt;code&gt;getNextFireTime()&lt;/code&gt;
     * should return a valid answer.
     * &lt;/p&gt;
     * 
     * @return the first time at which the &lt;code&gt;Trigger&lt;/code&gt; will be fired
     *         by the scheduler, which is also the same value &lt;code&gt;getNextFireTime()&lt;/code&gt;
     *         will return (until after the first firing of the &lt;code&gt;Trigger&lt;/code&gt;).
     *         &lt;/p&gt;
     */
    @Override
    public Date computeFirstFireTime(org.quartz.Calendar calendar) {
        
<span class="fc" id="L561">      nextFireTime = getFireTimeAfter(new Date(getStartTime().getTime() - 1000L));</span>
      
      // Check calendar for date-time exclusion
<span class="pc bpc" id="L564" title="1 of 4 branches missed.">      while (nextFireTime != null &amp;&amp; calendar != null</span>
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">              &amp;&amp; !calendar.isTimeIncluded(nextFireTime.getTime())) {</span>
          
<span class="nc" id="L567">          nextFireTime = getFireTimeAfter(nextFireTime);</span>
          
<span class="nc bnc" id="L569" title="All 2 branches missed.">          if(nextFireTime == null)</span>
<span class="nc" id="L570">              break;</span>
      
          //avoid infinite loop
<span class="nc" id="L573">          java.util.Calendar c = java.util.Calendar.getInstance();</span>
<span class="nc" id="L574">          c.setTime(nextFireTime);</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">          if (c.get(java.util.Calendar.YEAR) &gt; YEAR_TO_GIVEUP_SCHEDULING_AT) {</span>
<span class="nc" id="L576">              return null;</span>
          }
<span class="nc" id="L578">      }</span>
      
<span class="fc" id="L580">      return nextFireTime;</span>
    }
    
    private Calendar createCalendarTime(Date dateTime) {
<span class="fc" id="L584">        Calendar cal = Calendar.getInstance();</span>
<span class="fc" id="L585">        cal.setTime(dateTime);</span>
<span class="fc" id="L586">        return cal;</span>
    }

    /**
     * &lt;p&gt;
     * Returns the next time at which the &lt;code&gt;Trigger&lt;/code&gt; is scheduled to fire. If
     * the trigger will not fire again, &lt;code&gt;null&lt;/code&gt; will be returned.  Note that
     * the time returned can possibly be in the past, if the time that was computed
     * for the trigger to next fire has already arrived, but the scheduler has not yet
     * been able to fire the trigger (which would likely be due to lack of resources
     * e.g. threads).
     * &lt;/p&gt;
     *
     * &lt;p&gt;The value returned is not guaranteed to be valid until after the &lt;code&gt;Trigger&lt;/code&gt;
     * has been added to the scheduler.
     * &lt;/p&gt;
     */
    @Override
    public Date getNextFireTime() {
<span class="fc" id="L605">        return nextFireTime;</span>
    }

    /**
     * &lt;p&gt;
     * Returns the previous time at which the &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; 
     * fired. If the trigger has not yet fired, &lt;code&gt;null&lt;/code&gt; will be
     * returned.
     */
    @Override
    public Date getPreviousFireTime() {
<span class="nc" id="L616">        return previousFireTime;</span>
    }

    /**
     * &lt;p&gt;
     * Set the next time at which the &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; should fire.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * &lt;b&gt;This method should not be invoked by client code.&lt;/b&gt;
     * &lt;/p&gt;
     */
    public void setNextFireTime(Date nextFireTime) {
<span class="nc" id="L629">        this.nextFireTime = nextFireTime;</span>
<span class="nc" id="L630">    }</span>

    /**
     * &lt;p&gt;
     * Set the previous time at which the &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; fired.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * &lt;b&gt;This method should not be invoked by client code.&lt;/b&gt;
     * &lt;/p&gt;
     */
    public void setPreviousFireTime(Date previousFireTime) {
<span class="nc" id="L642">        this.previousFireTime = previousFireTime;</span>
<span class="nc" id="L643">    }</span>

    /**
     * &lt;p&gt;
     * Returns the next time at which the &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; will
     * fire, after the given time. If the trigger will not fire after the given
     * time, &lt;code&gt;null&lt;/code&gt; will be returned.
     * &lt;/p&gt;
     */
    @Override
    public Date getFireTimeAfter(Date afterTime) {
        // Check if trigger has completed or not.
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">        if (complete) {</span>
<span class="nc" id="L656">            return null;</span>
        }
        
        // Check repeatCount limit
<span class="fc bfc" id="L660" title="All 4 branches covered.">        if (repeatCount != REPEAT_INDEFINITELY &amp;&amp; timesTriggered &gt; repeatCount) {</span>
<span class="fc" id="L661">          return null;</span>
        }
      
        // a. Increment afterTime by a second, so that we are comparing against a time after it!
<span class="pc bpc" id="L665" title="1 of 2 branches missed.">        if (afterTime == null) {</span>
<span class="nc" id="L666">          afterTime = new Date(System.currentTimeMillis() + 1000L);</span>
        } else {
<span class="fc" id="L668">          afterTime = new Date(afterTime.getTime() + 1000L);</span>
        }
         
        // make sure afterTime is at least startTime
<span class="fc bfc" id="L672" title="All 2 branches covered.">        if(afterTime.before(startTime))</span>
<span class="fc" id="L673">          afterTime = startTime;</span>

        // b.Check to see if afterTime is after endTimeOfDay or not. If yes, then we need to advance to next day as well.
<span class="fc" id="L676">        boolean afterTimePastEndTimeOfDay = false;</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">        if (endTimeOfDay != null) {</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">          afterTimePastEndTimeOfDay = afterTime.getTime() &gt; endTimeOfDay.getTimeOfDayForDate(afterTime).getTime();</span>
        }
        // c. now we need to move move to the next valid day of week if either: 
        // the given time is past the end time of day, or given time is not on a valid day of week
<span class="fc" id="L682">        Date fireTime = advanceToNextDayOfWeekIfNecessary(afterTime, afterTimePastEndTimeOfDay);</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">        if (fireTime == null)</span>
<span class="fc" id="L684">          return null;</span>
                
        // d. Calculate and save fireTimeEndDate variable for later use
<span class="fc" id="L687">        Date fireTimeEndDate = null;</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">        if (endTimeOfDay == null)</span>
<span class="fc" id="L689">          fireTimeEndDate = new TimeOfDay(23, 59, 59).getTimeOfDayForDate(fireTime);</span>
        else
<span class="fc" id="L691">          fireTimeEndDate = endTimeOfDay.getTimeOfDayForDate(fireTime);</span>
        
        // e. Check fireTime against startTime or startTimeOfDay to see which go first.
<span class="fc" id="L694">        Date fireTimeStartDate = startTimeOfDay.getTimeOfDayForDate(fireTime);</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">        if (fireTime.before(fireTimeStartDate)) {</span>
<span class="fc" id="L696">          return fireTimeStartDate;</span>
        } 
        
        
        // f. Continue to calculate the fireTime by incremental unit of intervals.
        // recall that if fireTime was less that fireTimeStartDate, we didn't get this far
<span class="fc" id="L702">        long fireMillis = fireTime.getTime();</span>
<span class="fc" id="L703">        long startMillis = fireTimeStartDate.getTime();</span>
<span class="fc" id="L704">        long secondsAfterStart = (fireMillis - startMillis) / 1000L;</span>
<span class="fc" id="L705">        long repeatLong = getRepeatInterval();</span>
<span class="fc" id="L706">        Calendar sTime = createCalendarTime(fireTimeStartDate);</span>
<span class="fc" id="L707">        IntervalUnit repeatUnit = getRepeatIntervalUnit();</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">        if(repeatUnit.equals(IntervalUnit.SECOND)) {</span>
<span class="fc" id="L709">            long jumpCount = secondsAfterStart / repeatLong;</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">            if(secondsAfterStart % repeatLong != 0)</span>
<span class="fc" id="L711">                jumpCount++;</span>
<span class="fc" id="L712">            sTime.add(Calendar.SECOND, getRepeatInterval() * (int)jumpCount);</span>
<span class="fc" id="L713">            fireTime = sTime.getTime();</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">        } else if(repeatUnit.equals(IntervalUnit.MINUTE)) {</span>
<span class="fc" id="L715">            long jumpCount = secondsAfterStart / (repeatLong * 60L);</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">            if(secondsAfterStart % (repeatLong * 60L) != 0)</span>
<span class="fc" id="L717">                jumpCount++;</span>
<span class="fc" id="L718">            sTime.add(Calendar.MINUTE, getRepeatInterval() * (int)jumpCount);</span>
<span class="fc" id="L719">            fireTime = sTime.getTime();</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">        } else if(repeatUnit.equals(IntervalUnit.HOUR)) {</span>
<span class="fc" id="L721">            long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);</span>
<span class="fc bfc" id="L722" title="All 2 branches covered.">            if(secondsAfterStart % (repeatLong * 60L * 60L) != 0)</span>
<span class="fc" id="L723">                jumpCount++;</span>
<span class="fc" id="L724">            sTime.add(Calendar.HOUR_OF_DAY, getRepeatInterval() * (int)jumpCount);</span>
<span class="fc" id="L725">            fireTime = sTime.getTime();</span>
        }
        
        // g. Ensure this new fireTime is within the day, or else we need to advance to next day.
<span class="fc bfc" id="L729" title="All 2 branches covered.">        if (fireTime.after(fireTimeEndDate)) {</span>
<span class="fc" id="L730">          fireTime = advanceToNextDayOfWeekIfNecessary(fireTime, isSameDay(fireTime, fireTimeEndDate));</span>
          // make sure we hit the startTimeOfDay on the new day
<span class="fc" id="L732">          fireTime = startTimeOfDay.getTimeOfDayForDate(fireTime);</span>
        }
    
        // i. Return calculated fireTime.
<span class="fc" id="L736">        return fireTime;</span>
    }

    private boolean isSameDay(Date d1, Date d2) {
    
<span class="fc" id="L741">      Calendar c1 = createCalendarTime(d1);</span>
<span class="fc" id="L742">      Calendar c2 = createCalendarTime(d2);</span>
      
<span class="pc bpc" id="L744" title="1 of 4 branches missed.">      return c1.get(Calendar.YEAR) == c2.get(Calendar.YEAR) &amp;&amp; c1.get(Calendar.DAY_OF_YEAR) == c2.get(Calendar.DAY_OF_YEAR);</span>
    }
    
    /**
     * Given fireTime time determine if it is on a valid day of week. If so, simply return it unaltered,
     * if not, advance to the next valid week day, and set the time of day to the start time of day
     * 
     * @param fireTime - given next fireTime.
     * @param forceToAdvanceNextDay - flag to whether to advance day without check existing week day. This scenario
     * can happen when a caller determine fireTime has passed the endTimeOfDay that fireTime should move to next day anyway.
     * @return a next day fireTime.
     */
    private Date advanceToNextDayOfWeekIfNecessary(Date fireTime, boolean forceToAdvanceNextDay) {
        // a. Advance or adjust to next dayOfWeek if need to first, starting next day with startTimeOfDay.
<span class="fc" id="L758">        TimeOfDay sTimeOfDay = getStartTimeOfDay();</span>
<span class="fc" id="L759">        Date fireTimeStartDate = sTimeOfDay.getTimeOfDayForDate(fireTime);      </span>
<span class="fc" id="L760">        Calendar fireTimeStartDateCal = createCalendarTime(fireTimeStartDate);          </span>
<span class="fc" id="L761">        int dayOfWeekOfFireTime = fireTimeStartDateCal.get(Calendar.DAY_OF_WEEK);</span>
        
        // b2. We need to advance to another day if isAfterTimePassEndTimeOfDay is true, or dayOfWeek is not set.
<span class="fc" id="L764">        Set&lt;Integer&gt; daysOfWeekToFire = getDaysOfWeek();</span>
<span class="fc bfc" id="L765" title="All 4 branches covered.">        if (forceToAdvanceNextDay || !daysOfWeekToFire.contains(dayOfWeekOfFireTime)) {</span>
          // Advance one day at a time until next available date.
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">          for(int i=1; i &lt;= 7; i++) {</span>
<span class="fc" id="L768">            fireTimeStartDateCal.add(Calendar.DATE, 1);</span>
<span class="fc" id="L769">            dayOfWeekOfFireTime = fireTimeStartDateCal.get(Calendar.DAY_OF_WEEK);</span>
<span class="fc bfc" id="L770" title="All 2 branches covered.">            if (daysOfWeekToFire.contains(dayOfWeekOfFireTime)) {</span>
<span class="fc" id="L771">              fireTime = fireTimeStartDateCal.getTime();</span>
<span class="fc" id="L772">              break;</span>
            }
          }
        }
        
        // Check fireTime not pass the endTime
<span class="fc" id="L778">         Date eTime = getEndTime();</span>
<span class="fc bfc" id="L779" title="All 4 branches covered.">         if (eTime != null &amp;&amp; fireTime.getTime() &gt; eTime.getTime()) {</span>
<span class="fc" id="L780">             return null;</span>
         }

<span class="fc" id="L783">        return fireTime;</span>
    }

    /**
     * &lt;p&gt;
     * Returns the final time at which the &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; will
     * fire, if there is no end time set, null will be returned.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * Note that the return time may be in the past.
     * &lt;/p&gt;
     */
    @Override
    public Date getFinalFireTime() {
<span class="nc bnc" id="L798" title="All 4 branches missed.">        if (complete || getEndTime() == null) {</span>
<span class="nc" id="L799">            return null;</span>
        }
        
        // We have an endTime, we still need to check to see if there is a endTimeOfDay if that's applicable.
<span class="nc" id="L803">        Date eTime = getEndTime();</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">        if (endTimeOfDay != null) {</span>
<span class="nc" id="L805">            Date endTimeOfDayDate = endTimeOfDay.getTimeOfDayForDate(eTime);</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">            if (eTime.getTime() &lt; endTimeOfDayDate.getTime()) {</span>
<span class="nc" id="L807">                eTime = endTimeOfDayDate;</span>
            }
        }        
<span class="nc" id="L810">        return eTime;</span>
    }

    /**
     * &lt;p&gt;
     * Determines whether or not the &lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; will occur
     * again.
     * &lt;/p&gt;
     */
    @Override
    public boolean mayFireAgain() {
<span class="nc bnc" id="L821" title="All 2 branches missed.">        return (getNextFireTime() != null);</span>
    }

    /**
     * &lt;p&gt;
     * Validates whether the properties of the &lt;code&gt;JobDetail&lt;/code&gt; are
     * valid for submission into a &lt;code&gt;Scheduler&lt;/code&gt;.
     * 
     * @throws IllegalStateException
     *           if a required property (such as Name, Group, Class) is not
     *           set.
     */
    @Override
    public void validate() throws SchedulerException {
<span class="fc" id="L835">        super.validate();</span>
        
<span class="pc bpc" id="L837" title="1 of 4 branches missed.">        if (repeatIntervalUnit == null || !(repeatIntervalUnit.equals(IntervalUnit.SECOND) || </span>
<span class="fc bfc" id="L838" title="All 4 branches covered.">                repeatIntervalUnit.equals(IntervalUnit.MINUTE) ||repeatIntervalUnit.equals(IntervalUnit.HOUR)))</span>
<span class="fc" id="L839">            throw new SchedulerException(&quot;Invalid repeat IntervalUnit (must be SECOND, MINUTE or HOUR).&quot;);</span>
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">        if (repeatInterval &lt; 1) {</span>
<span class="nc" id="L841">            throw new SchedulerException(&quot;Repeat Interval cannot be zero.&quot;);</span>
        }
        
        // Ensure interval does not exceed 24 hours
<span class="fc" id="L845">        long secondsInHour = 24 * 60 * 60L;</span>
<span class="fc bfc" id="L846" title="All 4 branches covered.">        if (repeatIntervalUnit == IntervalUnit.SECOND &amp;&amp; repeatInterval &gt; secondsInHour) {</span>
<span class="fc" id="L847">            throw new SchedulerException(&quot;repeatInterval can not exceed 24 hours (&quot; + secondsInHour + &quot; seconds). Given &quot; + repeatInterval);</span>
        }
<span class="fc bfc" id="L849" title="All 4 branches covered.">        if (repeatIntervalUnit == IntervalUnit.MINUTE &amp;&amp; repeatInterval &gt; secondsInHour / 60L) {</span>
<span class="fc" id="L850">            throw new SchedulerException(&quot;repeatInterval can not exceed 24 hours (&quot; + secondsInHour / 60L + &quot; minutes). Given &quot; + repeatInterval);</span>
        }
<span class="pc bpc" id="L852" title="1 of 4 branches missed.">        if (repeatIntervalUnit == IntervalUnit.HOUR &amp;&amp; repeatInterval &gt; 24 ) {</span>
<span class="fc" id="L853">            throw new SchedulerException(&quot;repeatInterval can not exceed 24 hours. Given &quot; + repeatInterval + &quot; hours.&quot;);</span>
        }        
        
        // Ensure timeOfDay is in order.
        // NOTE: We allow startTimeOfDay to be set equal to endTimeOfDay so the repeatCount can be
        // set to 1.
<span class="pc bpc" id="L859" title="1 of 2 branches missed.">        if (getEndTimeOfDay() != null</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">            &amp;&amp; !getStartTimeOfDay().equals(getEndTimeOfDay())</span>
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">            &amp;&amp; !getStartTimeOfDay().before(getEndTimeOfDay())) {</span>
<span class="nc" id="L862">            throw new SchedulerException(&quot;StartTimeOfDay &quot; + startTimeOfDay</span>
                + &quot; should not come after endTimeOfDay &quot; + endTimeOfDay);
        }
<span class="fc" id="L865">    }</span>

    /**
     * {@inheritDoc}
     */
    public Set&lt;Integer&gt; getDaysOfWeek() {
<span class="fc bfc" id="L871" title="All 2 branches covered.">        if (daysOfWeek == null) {</span>
<span class="fc" id="L872">            daysOfWeek = DailyTimeIntervalScheduleBuilder.ALL_DAYS_OF_THE_WEEK;</span>
        }
<span class="fc" id="L874">        return daysOfWeek;</span>
    }

    public void setDaysOfWeek(Set&lt;Integer&gt; daysOfWeek) {
<span class="pc bpc" id="L878" title="2 of 4 branches missed.">        if(daysOfWeek == null || daysOfWeek.size() == 0)</span>
<span class="nc" id="L879">            throw new IllegalArgumentException(&quot;DaysOfWeek set must be a set that contains at least one day.&quot;);</span>
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">        else if(daysOfWeek.size() == 0) </span>
<span class="nc" id="L881">            throw new IllegalArgumentException(&quot;DaysOfWeek set must contain at least one day.&quot;);</span>

<span class="fc" id="L883">        this.daysOfWeek = daysOfWeek;</span>
<span class="fc" id="L884">    }</span>

    /**
     * {@inheritDoc}
     */
    public TimeOfDay getStartTimeOfDay() {
<span class="fc bfc" id="L890" title="All 2 branches covered.">        if (startTimeOfDay == null) {</span>
<span class="fc" id="L891">            startTimeOfDay = new TimeOfDay(0, 0, 0);</span>
        }
<span class="fc" id="L893">        return startTimeOfDay;</span>
    }

    public void setStartTimeOfDay(TimeOfDay startTimeOfDay) {
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">        if (startTimeOfDay == null) {</span>
<span class="nc" id="L898">            throw new IllegalArgumentException(&quot;Start time of day cannot be null&quot;);</span>
        }

<span class="fc" id="L901">        TimeOfDay eTime = getEndTimeOfDay();</span>
<span class="pc bpc" id="L902" title="3 of 4 branches missed.">        if (eTime != null &amp;&amp; eTime.before(startTimeOfDay)) {</span>
<span class="nc" id="L903">            throw new IllegalArgumentException(</span>
                &quot;End time of day cannot be before start time of day&quot;);    
        }

<span class="fc" id="L907">        this.startTimeOfDay = startTimeOfDay;</span>
<span class="fc" id="L908">    }</span>

    /**
     * {@inheritDoc}
     */
    public TimeOfDay getEndTimeOfDay() {
<span class="fc" id="L914">        return endTimeOfDay;</span>
    }

    public void setEndTimeOfDay(TimeOfDay endTimeOfDay) {
<span class="pc bpc" id="L918" title="1 of 2 branches missed.">        if (endTimeOfDay == null) </span>
<span class="nc" id="L919">            throw new IllegalArgumentException(&quot;End time of day cannot be null&quot;);</span>

<span class="fc" id="L921">        TimeOfDay sTime = getStartTimeOfDay();</span>
<span class="pc bpc" id="L922" title="2 of 4 branches missed.">        if (sTime != null &amp;&amp; endTimeOfDay.before(endTimeOfDay)) {</span>
<span class="nc" id="L923">            throw new IllegalArgumentException(</span>
                    &quot;End time of day cannot be before start time of day&quot;);
        }
<span class="fc" id="L926">        this.endTimeOfDay = endTimeOfDay;</span>
<span class="fc" id="L927">    }</span>
    
    /**
     * Get a {@link ScheduleBuilder} that is configured to produce a 
     * schedule identical to this trigger's schedule.
     * 
     * @see #getTriggerBuilder()
     */
    @Override
    public ScheduleBuilder&lt;DailyTimeIntervalTrigger&gt; getScheduleBuilder() {
        
<span class="nc" id="L938">        DailyTimeIntervalScheduleBuilder cb = DailyTimeIntervalScheduleBuilder.dailyTimeIntervalSchedule()</span>
<span class="nc" id="L939">                .withInterval(getRepeatInterval(), getRepeatIntervalUnit())</span>
<span class="nc" id="L940">                .onDaysOfTheWeek(getDaysOfWeek()).startingDailyAt(getStartTimeOfDay()).endingDailyAt(getEndTimeOfDay());</span>
            
<span class="nc bnc" id="L942" title="All 3 branches missed.">        switch(getMisfireInstruction()) {</span>
<span class="nc" id="L943">            case MISFIRE_INSTRUCTION_DO_NOTHING : cb.withMisfireHandlingInstructionDoNothing();</span>
<span class="nc" id="L944">            break;</span>
<span class="nc" id="L945">            case MISFIRE_INSTRUCTION_FIRE_ONCE_NOW : cb.withMisfireHandlingInstructionFireAndProceed();</span>
            break;
        }
        
<span class="nc" id="L949">        return cb;</span>
    }

    /** This trigger has no additional properties besides what's defined in this class. */
    public boolean hasAdditionalProperties() {
<span class="nc" id="L954">        return false;</span>
    }
    
    public int getRepeatCount() {
<span class="nc" id="L958">        return repeatCount;</span>
    }
    
    public void setRepeatCount(int repeatCount) {
<span class="pc bpc" id="L962" title="1 of 4 branches missed.">        if (repeatCount &lt; 0 &amp;&amp; repeatCount != REPEAT_INDEFINITELY) {</span>
<span class="nc" id="L963">            throw new IllegalArgumentException(&quot;Repeat count must be &gt;= 0, use the &quot; +</span>
                    &quot;constant REPEAT_INDEFINITELY for infinite.&quot;);
        }

<span class="fc" id="L967">        this.repeatCount = repeatCount;</span>
<span class="fc" id="L968">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>