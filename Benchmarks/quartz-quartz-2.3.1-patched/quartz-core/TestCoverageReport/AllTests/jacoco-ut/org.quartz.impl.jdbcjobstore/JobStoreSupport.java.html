<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JobStoreSupport.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">quartz-core</a> &gt; <a href="index.source.html" class="el_package">org.quartz.impl.jdbcjobstore</a> &gt; <span class="el_source">JobStoreSupport.java</span></div><h1>JobStoreSupport.java</h1><pre class="source lang-java linenums">/* 
 * All content copyright Terracotta, Inc., unless otherwise indicated. All rights reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not 
 * use this file except in compliance with the License. You may obtain a copy 
 * of the License at 
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0 
 *   
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT 
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
 * License for the specific language governing permissions and limitations 
 * under the License.
 * 
 */

package org.quartz.impl.jdbcjobstore;

import java.io.IOException;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.quartz.Calendar;
import org.quartz.Job;
import org.quartz.JobDataMap;
import org.quartz.JobDetail;
import org.quartz.JobKey;
import org.quartz.JobPersistenceException;
import org.quartz.ObjectAlreadyExistsException;
import org.quartz.Scheduler;
import org.quartz.SchedulerConfigException;
import org.quartz.SchedulerException;
import org.quartz.SimpleTrigger;
import org.quartz.Trigger;
import org.quartz.Trigger.CompletedExecutionInstruction;
import org.quartz.Trigger.TriggerState;
import org.quartz.TriggerKey;
import org.quartz.impl.DefaultThreadExecutor;
import org.quartz.impl.matchers.GroupMatcher;
import org.quartz.impl.matchers.StringMatcher;
import org.quartz.impl.matchers.StringMatcher.StringOperatorName;
import org.quartz.impl.triggers.SimpleTriggerImpl;
import org.quartz.spi.ClassLoadHelper;
import org.quartz.spi.JobStore;
import org.quartz.spi.OperableTrigger;
import org.quartz.spi.SchedulerSignaler;
import org.quartz.spi.ThreadExecutor;
import org.quartz.spi.TriggerFiredBundle;
import org.quartz.spi.TriggerFiredResult;
import org.quartz.utils.DBConnectionManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * &lt;p&gt;
 * Contains base functionality for JDBC-based JobStore implementations.
 * &lt;/p&gt;
 * 
 * @author &lt;a href=&quot;mailto:jeff@binaryfeed.org&quot;&gt;Jeffrey Wescott&lt;/a&gt;
 * @author James House
 */
<span class="fc" id="L74">public abstract class JobStoreSupport implements JobStore, Constants {</span>

    /*
     * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     * 
     * Constants.
     * 
     * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     */

    protected static final String LOCK_TRIGGER_ACCESS = &quot;TRIGGER_ACCESS&quot;;

    protected static final String LOCK_STATE_ACCESS = &quot;STATE_ACCESS&quot;;

    /*
     * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     * 
     * Data members.
     * 
     * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     */

    protected String dsName;

<span class="fc" id="L98">    protected String tablePrefix = DEFAULT_TABLE_PREFIX;</span>

<span class="fc" id="L100">    protected boolean useProperties = false;</span>

    protected String instanceId;

    protected String instanceName;
    
    protected String delegateClassName;

    protected String delegateInitString;
    
<span class="fc" id="L110">    protected Class&lt;? extends DriverDelegate&gt; delegateClass = StdJDBCDelegate.class;</span>

<span class="fc" id="L112">    protected HashMap&lt;String, Calendar&gt; calendarCache = new HashMap&lt;String, Calendar&gt;();</span>

    private DriverDelegate delegate;

<span class="fc" id="L116">    private long misfireThreshold = 60000L; // one minute</span>

<span class="fc" id="L118">    private boolean dontSetAutoCommitFalse = false;</span>

<span class="fc" id="L120">    private boolean isClustered = false;</span>

<span class="fc" id="L122">    private boolean useDBLocks = false;</span>
    
<span class="fc" id="L124">    private boolean lockOnInsert = true;</span>

<span class="fc" id="L126">    private Semaphore lockHandler = null; // set in initialize() method...</span>

<span class="fc" id="L128">    private String selectWithLockSQL = null;</span>

<span class="fc" id="L130">    private long clusterCheckinInterval = 7500L;</span>

<span class="fc" id="L132">    private ClusterManager clusterManagementThread = null;</span>

<span class="fc" id="L134">    private MisfireHandler misfireHandler = null;</span>

    private ClassLoadHelper classLoadHelper;

    private SchedulerSignaler schedSignaler;

<span class="fc" id="L140">    protected int maxToRecoverAtATime = 20;</span>
    
<span class="fc" id="L142">    private boolean setTxIsolationLevelSequential = false;</span>
    
<span class="fc" id="L144">    private boolean acquireTriggersWithinLock = false;</span>
    
<span class="fc" id="L146">    private long dbRetryInterval = 15000L; // 15 secs</span>
    
<span class="fc" id="L148">    private boolean makeThreadsDaemons = false;</span>

<span class="fc" id="L150">    private boolean threadsInheritInitializersClassLoadContext = false;</span>
<span class="fc" id="L151">    private ClassLoader initializersLoader = null;</span>
    
<span class="fc" id="L153">    private boolean doubleCheckLockMisfireHandler = true;</span>
    
<span class="fc" id="L155">    private final Logger log = LoggerFactory.getLogger(getClass());</span>
    
<span class="fc" id="L157">    private ThreadExecutor threadExecutor = new DefaultThreadExecutor();</span>
    
<span class="fc" id="L159">    private volatile boolean schedulerRunning = false;</span>
<span class="fc" id="L160">    private volatile boolean shutdown = false;</span>
    
    /*
     * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     * 
     * Interface.
     * 
     * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     */

    /**
     * &lt;p&gt;
     * Set the name of the &lt;code&gt;DataSource&lt;/code&gt; that should be used for
     * performing database functions.
     * &lt;/p&gt;
     */
    public void setDataSource(String dsName) {
<span class="fc" id="L177">        this.dsName = dsName;</span>
<span class="fc" id="L178">    }</span>

    /**
     * &lt;p&gt;
     * Get the name of the &lt;code&gt;DataSource&lt;/code&gt; that should be used for
     * performing database functions.
     * &lt;/p&gt;
     */
    public String getDataSource() {
<span class="fc" id="L187">        return dsName;</span>
    }

    /**
     * &lt;p&gt;
     * Set the prefix that should be pre-pended to all table names.
     * &lt;/p&gt;
     */
    public void setTablePrefix(String prefix) {
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">        if (prefix == null) {</span>
<span class="nc" id="L197">            prefix = &quot;&quot;;</span>
        }

<span class="fc" id="L200">        this.tablePrefix = prefix;</span>
<span class="fc" id="L201">    }</span>

    /**
     * &lt;p&gt;
     * Get the prefix that should be pre-pended to all table names.
     * &lt;/p&gt;
     */
    public String getTablePrefix() {
<span class="fc" id="L209">        return tablePrefix;</span>
    }

    /**
     * &lt;p&gt;
     * Set whether String-only properties will be handled in JobDataMaps.
     * &lt;/p&gt;
     */
    @SuppressWarnings(&quot;UnusedDeclaration&quot;) /* called reflectively */
    public void setUseProperties(String useProp) {
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">        if (useProp == null) {</span>
<span class="nc" id="L220">            useProp = &quot;false&quot;;</span>
        }

<span class="fc" id="L223">        this.useProperties = Boolean.valueOf(useProp);</span>
<span class="fc" id="L224">    }</span>

    /**
     * &lt;p&gt;
     * Get whether String-only properties will be handled in JobDataMaps.
     * &lt;/p&gt;
     */
    public boolean canUseProperties() {
<span class="fc" id="L232">        return useProperties;</span>
    }

    /**
     * &lt;p&gt;
     * Set the instance Id of the Scheduler (must be unique within a cluster).
     * &lt;/p&gt;
     */
    public void setInstanceId(String instanceId) {
<span class="fc" id="L241">        this.instanceId = instanceId;</span>
<span class="fc" id="L242">    }</span>

    /**
     * &lt;p&gt;
     * Get the instance Id of the Scheduler (must be unique within a cluster).
     * &lt;/p&gt;
     */
    public String getInstanceId() {

<span class="fc" id="L251">        return instanceId;</span>
    }

    /**
     * Set the instance name of the Scheduler (must be unique within this server instance).
     */
    public void setInstanceName(String instanceName) {
<span class="fc" id="L258">        this.instanceName = instanceName;</span>
<span class="fc" id="L259">    }</span>

    public void setThreadPoolSize(final int poolSize) {
        //
<span class="fc" id="L263">    }</span>
    
    public void setThreadExecutor(ThreadExecutor threadExecutor) {
<span class="fc" id="L266">        this.threadExecutor = threadExecutor;</span>
<span class="fc" id="L267">    }</span>
    
    public ThreadExecutor getThreadExecutor() {
<span class="fc" id="L270">        return threadExecutor;</span>
    }
    

    /**
     * Get the instance name of the Scheduler (must be unique within this server instance).
     */
    public String getInstanceName() {

<span class="fc" id="L279">        return instanceName;</span>
    }

    public long getEstimatedTimeToReleaseAndAcquireTrigger() {
<span class="nc" id="L283">        return 70;</span>
    }

    /**
     * &lt;p&gt;
     * Set whether this instance is part of a cluster.
     * &lt;/p&gt;
     */
    @SuppressWarnings(&quot;UnusedDeclaration&quot;) /* called reflectively */
    public void setIsClustered(boolean isClustered) {
<span class="fc" id="L293">        this.isClustered = isClustered;</span>
<span class="fc" id="L294">    }</span>

    /**
     * &lt;p&gt;
     * Get whether this instance is part of a cluster.
     * &lt;/p&gt;
     */
    public boolean isClustered() {
<span class="fc" id="L302">        return isClustered;</span>
    }

    /**
     * &lt;p&gt;
     * Get the frequency (in milliseconds) at which this instance &quot;checks-in&quot;
     * with the other instances of the cluster. -- Affects the rate of
     * detecting failed instances.
     * &lt;/p&gt;
     */
    public long getClusterCheckinInterval() {
<span class="nc" id="L313">        return clusterCheckinInterval;</span>
    }

    /**
     * &lt;p&gt;
     * Set the frequency (in milliseconds) at which this instance &quot;checks-in&quot;
     * with the other instances of the cluster. -- Affects the rate of
     * detecting failed instances.
     * &lt;/p&gt;
     */
    @SuppressWarnings(&quot;UnusedDeclaration&quot;) /* called reflectively */
    public void setClusterCheckinInterval(long l) {
<span class="nc" id="L325">        clusterCheckinInterval = l;</span>
<span class="nc" id="L326">    }</span>

    /**
     * &lt;p&gt;
     * Get the maximum number of misfired triggers that the misfire handling
     * thread will try to recover at one time (within one transaction).  The
     * default is 20.
     * &lt;/p&gt;
     */
    public int getMaxMisfiresToHandleAtATime() {
<span class="fc" id="L336">        return maxToRecoverAtATime;</span>
    }

    /**
     * &lt;p&gt;
     * Set the maximum number of misfired triggers that the misfire handling
     * thread will try to recover at one time (within one transaction).  The
     * default is 20.
     * &lt;/p&gt;
     */
    @SuppressWarnings(&quot;UnusedDeclaration&quot;) /* called reflectively */
    public void setMaxMisfiresToHandleAtATime(int maxToRecoverAtATime) {
<span class="nc" id="L348">        this.maxToRecoverAtATime = maxToRecoverAtATime;</span>
<span class="nc" id="L349">    }</span>

    /**
     * @return Returns the dbRetryInterval.
     */
    public long getDbRetryInterval() {
<span class="fc" id="L355">        return dbRetryInterval;</span>
    }
    /**
     * @param dbRetryInterval The dbRetryInterval to set.
     */
    public void setDbRetryInterval(long dbRetryInterval) {
<span class="fc" id="L361">        this.dbRetryInterval = dbRetryInterval;</span>
<span class="fc" id="L362">    }</span>
    
    /**
     * &lt;p&gt;
     * Set whether this instance should use database-based thread
     * synchronization.
     * &lt;/p&gt;
     */
    public void setUseDBLocks(boolean useDBLocks) {
<span class="fc" id="L371">        this.useDBLocks = useDBLocks;</span>
<span class="fc" id="L372">    }</span>

    /**
     * &lt;p&gt;
     * Get whether this instance should use database-based thread
     * synchronization.
     * &lt;/p&gt;
     */
    public boolean getUseDBLocks() {
<span class="fc" id="L381">        return useDBLocks;</span>
    }

    public boolean isLockOnInsert() {
<span class="fc" id="L385">        return lockOnInsert;</span>
    }
    
    /**
     * Whether or not to obtain locks when inserting new jobs/triggers.  
     * &lt;p&gt;
     * Defaults to &lt;code&gt;true&lt;/code&gt;, which is safest. Some databases (such as 
     * MS SQLServer) seem to require this to avoid deadlocks under high load,
     * while others seem to do fine without.  Settings this to false means
     * isolation guarantees between job scheduling and trigger acquisition are
     * entirely enforced by the database.  Depending on the database and it's
     * configuration this may cause unusual scheduling behaviors.
     * 
     * &lt;p&gt;Setting this property to &lt;code&gt;false&lt;/code&gt; will provide a 
     * significant performance increase during the addition of new jobs 
     * and triggers.&lt;/p&gt;
     * 
     * @param lockOnInsert whether locking should be used when inserting new jobs/triggers
     */
    @SuppressWarnings(&quot;UnusedDeclaration&quot;) /* called reflectively */
    public void setLockOnInsert(boolean lockOnInsert) {
<span class="nc" id="L406">        this.lockOnInsert = lockOnInsert;</span>
<span class="nc" id="L407">    }</span>
    
    public long getMisfireThreshold() {
<span class="fc" id="L410">        return misfireThreshold;</span>
    }

    /**
     * The the number of milliseconds by which a trigger must have missed its
     * next-fire-time, in order for it to be considered &quot;misfired&quot; and thus
     * have its misfire instruction applied.
     * 
     * @param misfireThreshold the misfire threshold to use, in millis
     */
    @SuppressWarnings(&quot;UnusedDeclaration&quot;) /* called reflectively */
    public void setMisfireThreshold(long misfireThreshold) {
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">        if (misfireThreshold &lt; 1) {</span>
<span class="nc" id="L423">            throw new IllegalArgumentException(</span>
                    &quot;Misfirethreshold must be larger than 0&quot;);
        }
<span class="fc" id="L426">        this.misfireThreshold = misfireThreshold;</span>
<span class="fc" id="L427">    }</span>

    public boolean isDontSetAutoCommitFalse() {
<span class="fc" id="L430">        return dontSetAutoCommitFalse;</span>
    }

    /**
     * Don't call set autocommit(false) on connections obtained from the
     * DataSource. This can be helpful in a few situations, such as if you
     * have a driver that complains if it is called when it is already off.
     * 
     * @param b whether or not autocommit should be set to false on db connections
     */
    @SuppressWarnings(&quot;UnusedDeclaration&quot;) /* called reflectively */
    public void setDontSetAutoCommitFalse(boolean b) {
<span class="nc" id="L442">        dontSetAutoCommitFalse = b;</span>
<span class="nc" id="L443">    }</span>

    public boolean isTxIsolationLevelSerializable() {
<span class="fc" id="L446">        return setTxIsolationLevelSequential;</span>
    }

    /**
     * Set the transaction isolation level of DB connections to sequential.
     * 
     * @param b whether isolation level should be set to sequential.
     */
    @SuppressWarnings(&quot;UnusedDeclaration&quot;) /* called reflectively */
    public void setTxIsolationLevelSerializable(boolean b) {
<span class="nc" id="L456">        setTxIsolationLevelSequential = b;</span>
<span class="nc" id="L457">    }</span>

    /**
     * Whether or not the query and update to acquire a Trigger for firing
     * should be performed after obtaining an explicit DB lock (to avoid 
     * possible race conditions on the trigger's db row).  This is the
     * behavior prior to Quartz 1.6.3, but is considered unnecessary for most
     * databases (due to the nature of the SQL update that is performed), 
     * and therefore a superfluous performance hit.     
     */
    public boolean isAcquireTriggersWithinLock() {
<span class="fc" id="L468">        return acquireTriggersWithinLock;</span>
    }

    /**
     * Whether or not the query and update to acquire a Trigger for firing
     * should be performed after obtaining an explicit DB lock.  This is the
     * behavior prior to Quartz 1.6.3, but is considered unnecessary for most
     * databases, and therefore a superfluous performance hit.     
     * 
     * However, if batch acquisition is used, it is important for this behavior
     * to be used for all dbs.
     */
    @SuppressWarnings(&quot;UnusedDeclaration&quot;) /* called reflectively */
    public void setAcquireTriggersWithinLock(boolean acquireTriggersWithinLock) {
<span class="fc" id="L482">        this.acquireTriggersWithinLock = acquireTriggersWithinLock;</span>
<span class="fc" id="L483">    }</span>

    
    /**
     * &lt;p&gt;
     * Set the JDBC driver delegate class.
     * &lt;/p&gt;
     * 
     * @param delegateClassName
     *          the delegate class name
     */
    @SuppressWarnings(&quot;UnusedDeclaration&quot;) /* called reflectively */
    public void setDriverDelegateClass(String delegateClassName)
        throws InvalidConfigurationException {
<span class="fc" id="L497">        synchronized(this) {</span>
<span class="fc" id="L498">            this.delegateClassName = delegateClassName;</span>
<span class="fc" id="L499">        }</span>
<span class="fc" id="L500">    }</span>

    /**
     * &lt;p&gt;
     * Get the JDBC driver delegate class name.
     * &lt;/p&gt;
     * 
     * @return the delegate class name
     */
    public String getDriverDelegateClass() {
<span class="fc" id="L510">        return delegateClassName;</span>
    }

    /**
     * &lt;p&gt;
     * Set the JDBC driver delegate's initialization string.
     * &lt;/p&gt;
     * 
     * @param delegateInitString
     *          the delegate init string
     */
    @SuppressWarnings(&quot;UnusedDeclaration&quot;) /* called reflectively */
    public void setDriverDelegateInitString(String delegateInitString)
        throws InvalidConfigurationException {
<span class="nc" id="L524">        this.delegateInitString = delegateInitString;</span>
<span class="nc" id="L525">    }</span>

    /**
     * &lt;p&gt;
     * Get the JDBC driver delegate's initialization string.
     * &lt;/p&gt;
     * 
     * @return the delegate init string
     */
    public String getDriverDelegateInitString() {
<span class="fc" id="L535">        return delegateInitString;</span>
    }

    public String getSelectWithLockSQL() {
<span class="fc" id="L539">        return selectWithLockSQL;</span>
    }

    /**
     * &lt;p&gt;
     * set the SQL statement to use to select and lock a row in the &quot;locks&quot;
     * table.
     * &lt;/p&gt;
     * 
     * @see StdRowLockSemaphore
     */
    public void setSelectWithLockSQL(String string) {
<span class="nc" id="L551">        selectWithLockSQL = string;</span>
<span class="nc" id="L552">    }</span>

    protected ClassLoadHelper getClassLoadHelper() {
<span class="fc" id="L555">        return classLoadHelper;</span>
    }

    /**
     * Get whether the threads spawned by this JobStore should be
     * marked as daemon.  Possible threads include the &lt;code&gt;MisfireHandler&lt;/code&gt; 
     * and the &lt;code&gt;ClusterManager&lt;/code&gt;.
     * 
     * @see Thread#setDaemon(boolean)
     */
    public boolean getMakeThreadsDaemons() {
<span class="fc" id="L566">        return makeThreadsDaemons;</span>
    }

    /**
     * Set whether the threads spawned by this JobStore should be
     * marked as daemon.  Possible threads include the &lt;code&gt;MisfireHandler&lt;/code&gt; 
     * and the &lt;code&gt;ClusterManager&lt;/code&gt;.
     *
     * @see Thread#setDaemon(boolean)
     */
    @SuppressWarnings(&quot;UnusedDeclaration&quot;) /* called reflectively */
    public void setMakeThreadsDaemons(boolean makeThreadsDaemons) {
<span class="nc" id="L578">        this.makeThreadsDaemons = makeThreadsDaemons;</span>
<span class="nc" id="L579">    }</span>
    
    /**
     * Get whether to set the class load context of spawned threads to that
     * of the initializing thread.
     */
    public boolean isThreadsInheritInitializersClassLoadContext() {
<span class="fc" id="L586">        return threadsInheritInitializersClassLoadContext;</span>
    }

    /**
     * Set whether to set the class load context of spawned threads to that
     * of the initializing thread.
     */
    public void setThreadsInheritInitializersClassLoadContext(
            boolean threadsInheritInitializersClassLoadContext) {
<span class="nc" id="L595">        this.threadsInheritInitializersClassLoadContext = threadsInheritInitializersClassLoadContext;</span>
<span class="nc" id="L596">    }</span>

    /**
     * Get whether to check to see if there are Triggers that have misfired
     * before actually acquiring the lock to recover them.  This should be 
     * set to false if the majority of the time, there are are misfired
     * Triggers.
     */
    public boolean getDoubleCheckLockMisfireHandler() {
<span class="fc" id="L605">        return doubleCheckLockMisfireHandler;</span>
    }

    /**
     * Set whether to check to see if there are Triggers that have misfired
     * before actually acquiring the lock to recover them.  This should be 
     * set to false if the majority of the time, there are are misfired
     * Triggers.
     */
    @SuppressWarnings(&quot;UnusedDeclaration&quot;) /* called reflectively */
    public void setDoubleCheckLockMisfireHandler(
            boolean doubleCheckLockMisfireHandler) {
<span class="nc" id="L617">        this.doubleCheckLockMisfireHandler = doubleCheckLockMisfireHandler;</span>
<span class="nc" id="L618">    }</span>

    @Override
    public long getAcquireRetryDelay(int failureCount) {
<span class="fc" id="L622">        return dbRetryInterval;</span>
    }

    //---------------------------------------------------------------------------
    // interface methods
    //---------------------------------------------------------------------------

    protected Logger getLog() {
<span class="fc" id="L630">        return log;</span>
    }

    /**
     * &lt;p&gt;
     * Called by the QuartzScheduler before the &lt;code&gt;JobStore&lt;/code&gt; is
     * used, in order to give it a chance to initialize.
     * &lt;/p&gt;
     */
    public void initialize(ClassLoadHelper loadHelper,
            SchedulerSignaler signaler) throws SchedulerConfigException {

<span class="pc bpc" id="L642" title="1 of 2 branches missed.">        if (dsName == null) { </span>
<span class="nc" id="L643">            throw new SchedulerConfigException(&quot;DataSource name not set.&quot;); </span>
        }

<span class="fc" id="L646">        classLoadHelper = loadHelper;</span>
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">        if(isThreadsInheritInitializersClassLoadContext()) {</span>
<span class="nc" id="L648">            log.info(&quot;JDBCJobStore threads will inherit ContextClassLoader of thread: &quot; + Thread.currentThread().getName());</span>
<span class="nc" id="L649">            initializersLoader = Thread.currentThread().getContextClassLoader();</span>
        }
        
<span class="fc" id="L652">        this.schedSignaler = signaler;</span>

        // If the user hasn't specified an explicit lock handler, then 
        // choose one based on CMT/Clustered/UseDBLocks.
<span class="fc bfc" id="L656" title="All 2 branches covered.">        if (getLockHandler() == null) {</span>
            
            // If the user hasn't specified an explicit lock handler, 
            // then we *must* use DB locks with clustering
<span class="fc bfc" id="L660" title="All 2 branches covered.">            if (isClustered()) {</span>
<span class="fc" id="L661">                setUseDBLocks(true);</span>
            }
            
<span class="fc bfc" id="L664" title="All 2 branches covered.">            if (getUseDBLocks()) {</span>
<span class="pc bpc" id="L665" title="3 of 4 branches missed.">                if(getDriverDelegateClass() != null &amp;&amp; getDriverDelegateClass().equals(MSSQLDelegate.class.getName())) {</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">                    if(getSelectWithLockSQL() == null) {</span>
<span class="nc" id="L667">                        String msSqlDflt = &quot;SELECT * FROM {0}LOCKS WITH (UPDLOCK,ROWLOCK) WHERE &quot; + COL_SCHEDULER_NAME + &quot; = {1} AND LOCK_NAME = ?&quot;;</span>
<span class="nc" id="L668">                        getLog().info(&quot;Detected usage of MSSQLDelegate class - defaulting 'selectWithLockSQL' to '&quot; + msSqlDflt + &quot;'.&quot;);</span>
<span class="nc" id="L669">                        setSelectWithLockSQL(msSqlDflt);</span>
                    }
                }
<span class="fc" id="L672">                getLog().info(&quot;Using db table-based data access locking (synchronization).&quot;);</span>
<span class="fc" id="L673">                setLockHandler(new StdRowLockSemaphore(getTablePrefix(), getInstanceName(), getSelectWithLockSQL()));</span>
            } else {
<span class="fc" id="L675">                getLog().info(</span>
                    &quot;Using thread monitor-based data access locking (synchronization).&quot;);
<span class="fc" id="L677">                setLockHandler(new SimpleSemaphore());</span>
            }
        }

<span class="fc" id="L681">    }</span>
   
    /**
     * @see org.quartz.spi.JobStore#schedulerStarted()
     */
    public void schedulerStarted() throws SchedulerException {

<span class="pc bpc" id="L688" title="1 of 2 branches missed.">        if (isClustered()) {</span>
<span class="nc" id="L689">            clusterManagementThread = new ClusterManager();</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">            if(initializersLoader != null)</span>
<span class="nc" id="L691">                clusterManagementThread.setContextClassLoader(initializersLoader);</span>
<span class="nc" id="L692">            clusterManagementThread.initialize();</span>
        } else {
            try {
<span class="fc" id="L695">                recoverJobs();</span>
<span class="fc" id="L696">            } catch (SchedulerException se) {</span>
<span class="fc" id="L697">                throw new SchedulerConfigException(</span>
                        &quot;Failure occured during job recovery.&quot;, se);
<span class="fc" id="L699">            }</span>
        }

<span class="fc" id="L702">        misfireHandler = new MisfireHandler();</span>
<span class="pc bpc" id="L703" title="1 of 2 branches missed.">        if(initializersLoader != null)</span>
<span class="nc" id="L704">            misfireHandler.setContextClassLoader(initializersLoader);</span>
<span class="fc" id="L705">        misfireHandler.initialize();</span>
<span class="fc" id="L706">        schedulerRunning = true;</span>
        
<span class="fc" id="L708">        getLog().debug(&quot;JobStore background threads started (as scheduler was started).&quot;);</span>
<span class="fc" id="L709">    }</span>
    
    public void schedulerPaused() {
<span class="fc" id="L712">        schedulerRunning = false;</span>
<span class="fc" id="L713">    }</span>
    
    public void schedulerResumed() {
<span class="nc" id="L716">        schedulerRunning = true;</span>
<span class="nc" id="L717">    }</span>
    
    /**
     * &lt;p&gt;
     * Called by the QuartzScheduler to inform the &lt;code&gt;JobStore&lt;/code&gt; that
     * it should free up all of it's resources because the scheduler is
     * shutting down.
     * &lt;/p&gt;
     */
    public void shutdown() {
<span class="fc" id="L727">        shutdown = true;</span>
        
<span class="fc bfc" id="L729" title="All 2 branches covered.">        if (misfireHandler != null) {</span>
<span class="fc" id="L730">            misfireHandler.shutdown();</span>
            try {
<span class="fc" id="L732">                misfireHandler.join();</span>
<span class="nc" id="L733">            } catch (InterruptedException ignore) {</span>
<span class="fc" id="L734">            }</span>
        }

<span class="pc bpc" id="L737" title="1 of 2 branches missed.">        if (clusterManagementThread != null) {</span>
<span class="nc" id="L738">            clusterManagementThread.shutdown();</span>
            try {
<span class="nc" id="L740">                clusterManagementThread.join();</span>
<span class="nc" id="L741">            } catch (InterruptedException ignore) {</span>
<span class="nc" id="L742">            }</span>
        }

        try {
<span class="fc" id="L746">            DBConnectionManager.getInstance().shutdown(getDataSource());</span>
<span class="nc" id="L747">        } catch (SQLException sqle) {</span>
<span class="nc" id="L748">            getLog().warn(&quot;Database connection shutdown unsuccessful.&quot;, sqle);</span>
<span class="fc" id="L749">        }        </span>
        
<span class="fc" id="L751">        getLog().debug(&quot;JobStore background threads shutdown.&quot;);</span>
<span class="fc" id="L752">    }</span>

    public boolean supportsPersistence() {
<span class="fc" id="L755">        return true;</span>
    }

    //---------------------------------------------------------------------------
    // helper methods for subclasses
    //---------------------------------------------------------------------------

    protected abstract Connection getNonManagedTXConnection()
        throws JobPersistenceException;

    /**
     * Wrap the given &lt;code&gt;Connection&lt;/code&gt; in a Proxy such that attributes 
     * that might be set will be restored before the connection is closed 
     * (and potentially restored to a pool).
     */
    protected Connection getAttributeRestoringConnection(Connection conn) {
<span class="fc" id="L771">        return (Connection)Proxy.newProxyInstance(</span>
<span class="fc" id="L772">                Thread.currentThread().getContextClassLoader(),</span>
                new Class[] { Connection.class },
                new AttributeRestoringConnectionInvocationHandler(conn));
    }
    
    protected Connection getConnection() throws JobPersistenceException {
        Connection conn;
        try {
<span class="fc" id="L780">            conn = DBConnectionManager.getInstance().getConnection(</span>
<span class="fc" id="L781">                    getDataSource());</span>
<span class="fc" id="L782">        } catch (SQLException sqle) {</span>
<span class="fc" id="L783">            throw new JobPersistenceException(</span>
                    &quot;Failed to obtain DB connection from data source '&quot;
<span class="fc" id="L785">                    + getDataSource() + &quot;': &quot; + sqle.toString(), sqle);</span>
<span class="nc" id="L786">        } catch (Throwable e) {</span>
<span class="nc" id="L787">            throw new JobPersistenceException(</span>
                    &quot;Failed to obtain DB connection from data source '&quot;
<span class="nc" id="L789">                    + getDataSource() + &quot;': &quot; + e.toString(), e);</span>
<span class="fc" id="L790">        }</span>

<span class="pc bpc" id="L792" title="1 of 2 branches missed.">        if (conn == null) { </span>
<span class="nc" id="L793">            throw new JobPersistenceException(</span>
                &quot;Could not get connection from DataSource '&quot;
<span class="nc" id="L795">                + getDataSource() + &quot;'&quot;); </span>
        }

        // Protect connection attributes we might change.
<span class="fc" id="L799">        conn = getAttributeRestoringConnection(conn);</span>

        // Set any connection connection attributes we are to override.
        try {
<span class="pc bpc" id="L803" title="1 of 2 branches missed.">            if (!isDontSetAutoCommitFalse()) {</span>
<span class="fc" id="L804">                conn.setAutoCommit(false);</span>
            }

<span class="pc bpc" id="L807" title="1 of 2 branches missed.">            if(isTxIsolationLevelSerializable()) {</span>
<span class="nc" id="L808">                conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);</span>
            }
<span class="nc" id="L810">        } catch (SQLException sqle) {</span>
<span class="nc" id="L811">            getLog().warn(&quot;Failed to override connection auto commit/transaction isolation.&quot;, sqle);</span>
<span class="nc" id="L812">        } catch (Throwable e) {</span>
<span class="nc" id="L813">            try { conn.close(); } catch(Throwable ignored) {}</span>
            
<span class="nc" id="L815">            throw new JobPersistenceException(</span>
                &quot;Failure setting up connection.&quot;, e);
<span class="pc" id="L817">        }</span>
    
<span class="fc" id="L819">        return conn;</span>
    }

    protected void releaseLock(String lockName, boolean doIt) {
<span class="fc bfc" id="L823" title="All 2 branches covered.">        if (doIt) {</span>
            try {
<span class="fc" id="L825">                getLockHandler().releaseLock(lockName);</span>
<span class="nc" id="L826">            } catch (LockException le) {</span>
<span class="nc" id="L827">                getLog().error(&quot;Error returning lock: &quot; + le.getMessage(), le);</span>
<span class="fc" id="L828">            }</span>
        }
<span class="fc" id="L830">    }</span>

    /**
     * Recover any failed or misfired jobs and clean up the data store as
     * appropriate.
     * 
     * @throws JobPersistenceException if jobs could not be recovered
     */
    protected void recoverJobs() throws JobPersistenceException {
<span class="fc" id="L839">        executeInNonManagedTXLock(</span>
            LOCK_TRIGGER_ACCESS,
<span class="fc" id="L841">            new VoidTransactionCallback() {</span>
                public void executeVoid(Connection conn) throws JobPersistenceException {
<span class="fc" id="L843">                    recoverJobs(conn);</span>
<span class="fc" id="L844">                }</span>
            }, null);
<span class="fc" id="L846">    }</span>
    
    /**
     * &lt;p&gt;
     * Will recover any failed or misfired jobs and clean up the data store as
     * appropriate.
     * &lt;/p&gt;
     * 
     * @throws JobPersistenceException
     *           if jobs could not be recovered
     */
    protected void recoverJobs(Connection conn) throws JobPersistenceException {
        try {
            // update inconsistent job states
<span class="fc" id="L860">            int rows = getDelegate().updateTriggerStatesFromOtherStates(conn,</span>
                    STATE_WAITING, STATE_ACQUIRED, STATE_BLOCKED);

<span class="fc" id="L863">            rows += getDelegate().updateTriggerStatesFromOtherStates(conn,</span>
                        STATE_PAUSED, STATE_PAUSED_BLOCKED, STATE_PAUSED_BLOCKED);
            
<span class="fc" id="L866">            getLog().info(</span>
                    &quot;Freed &quot; + rows
                            + &quot; triggers from 'acquired' / 'blocked' state.&quot;);

            // clean up misfired jobs
<span class="fc" id="L871">            recoverMisfiredJobs(conn, true);</span>
            
            // recover jobs marked for recovery that were not fully executed
<span class="fc" id="L874">            List&lt;OperableTrigger&gt; recoveringJobTriggers = getDelegate()</span>
<span class="fc" id="L875">                    .selectTriggersForRecoveringJobs(conn);</span>
<span class="fc" id="L876">            getLog()</span>
<span class="fc" id="L877">                    .info(</span>
                            &quot;Recovering &quot;
<span class="fc" id="L879">                                    + recoveringJobTriggers.size()</span>
                                    + &quot; jobs that were in-progress at the time of the last shut-down.&quot;);

<span class="pc bpc" id="L882" title="1 of 2 branches missed.">            for (OperableTrigger recoveringJobTrigger: recoveringJobTriggers) {</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">                if (jobExists(conn, recoveringJobTrigger.getJobKey())) {</span>
<span class="nc" id="L884">                    recoveringJobTrigger.computeFirstFireTime(null);</span>
<span class="nc" id="L885">                    storeTrigger(conn, recoveringJobTrigger, null, false,</span>
                            STATE_WAITING, false, true);
                }
<span class="nc" id="L888">            }</span>
<span class="fc" id="L889">            getLog().info(&quot;Recovery complete.&quot;);</span>

            // remove lingering 'complete' triggers...
<span class="fc" id="L892">            List&lt;TriggerKey&gt; cts = getDelegate().selectTriggersInState(conn, STATE_COMPLETE);</span>
<span class="pc bpc" id="L893" title="1 of 2 branches missed.">            for(TriggerKey ct: cts) {</span>
<span class="nc" id="L894">                removeTrigger(conn, ct);</span>
<span class="nc" id="L895">            }</span>
<span class="fc" id="L896">            getLog().info(</span>
<span class="fc" id="L897">                &quot;Removed &quot; + cts.size() + &quot; 'complete' triggers.&quot;);</span>
            
            // clean up any fired trigger entries
<span class="fc" id="L900">            int n = getDelegate().deleteFiredTriggers(conn);</span>
<span class="fc" id="L901">            getLog().info(&quot;Removed &quot; + n + &quot; stale fired job entries.&quot;);</span>
<span class="nc" id="L902">        } catch (JobPersistenceException e) {</span>
<span class="nc" id="L903">            throw e;</span>
<span class="nc" id="L904">        } catch (Exception e) {</span>
<span class="nc" id="L905">            throw new JobPersistenceException(&quot;Couldn't recover jobs: &quot;</span>
<span class="nc" id="L906">                    + e.getMessage(), e);</span>
<span class="fc" id="L907">        }</span>
<span class="fc" id="L908">    }</span>

    protected long getMisfireTime() {
<span class="fc" id="L911">        long misfireTime = System.currentTimeMillis();</span>
<span class="pc bpc" id="L912" title="1 of 2 branches missed.">        if (getMisfireThreshold() &gt; 0) {</span>
<span class="fc" id="L913">            misfireTime -= getMisfireThreshold();</span>
        }

<span class="pc bpc" id="L916" title="1 of 2 branches missed.">        return (misfireTime &gt; 0) ? misfireTime : 0;</span>
    }

    /**
     * Helper class for returning the composite result of trying
     * to recover misfired jobs.
     */
    protected static class RecoverMisfiredJobsResult {
<span class="fc" id="L924">        public static final RecoverMisfiredJobsResult NO_OP =</span>
            new RecoverMisfiredJobsResult(false, 0, Long.MAX_VALUE);
        
        private boolean _hasMoreMisfiredTriggers;
        private int _processedMisfiredTriggerCount;
        private long _earliestNewTime;
        
        public RecoverMisfiredJobsResult(
<span class="fc" id="L932">            boolean hasMoreMisfiredTriggers, int processedMisfiredTriggerCount, long earliestNewTime) {</span>
<span class="fc" id="L933">            _hasMoreMisfiredTriggers = hasMoreMisfiredTriggers;</span>
<span class="fc" id="L934">            _processedMisfiredTriggerCount = processedMisfiredTriggerCount;</span>
<span class="fc" id="L935">            _earliestNewTime = earliestNewTime;</span>
<span class="fc" id="L936">        }</span>
        
        public boolean hasMoreMisfiredTriggers() {
<span class="fc" id="L939">            return _hasMoreMisfiredTriggers;</span>
        }
        public int getProcessedMisfiredTriggerCount() {
<span class="fc" id="L942">            return _processedMisfiredTriggerCount;</span>
        } 
        public long getEarliestNewTime() {
<span class="fc" id="L945">            return _earliestNewTime;</span>
        } 
    }
    
    protected RecoverMisfiredJobsResult recoverMisfiredJobs(
        Connection conn, boolean recovering)
        throws JobPersistenceException, SQLException {

        // If recovering, we want to handle all of the misfired
        // triggers right away.
<span class="fc bfc" id="L955" title="All 2 branches covered.">        int maxMisfiresToHandleAtATime = </span>
<span class="fc" id="L956">            (recovering) ? -1 : getMaxMisfiresToHandleAtATime();</span>
        
<span class="fc" id="L958">        List&lt;TriggerKey&gt; misfiredTriggers = new LinkedList&lt;TriggerKey&gt;();</span>
<span class="fc" id="L959">        long earliestNewTime = Long.MAX_VALUE;</span>
        // We must still look for the MISFIRED state in case triggers were left 
        // in this state when upgrading to this version that does not support it. 
<span class="fc" id="L962">        boolean hasMoreMisfiredTriggers =</span>
<span class="fc" id="L963">            getDelegate().hasMisfiredTriggersInState(</span>
<span class="fc" id="L964">                conn, STATE_WAITING, getMisfireTime(), </span>
                maxMisfiresToHandleAtATime, misfiredTriggers);

<span class="pc bpc" id="L967" title="1 of 2 branches missed.">        if (hasMoreMisfiredTriggers) {</span>
<span class="nc" id="L968">            getLog().info(</span>
<span class="nc" id="L969">                &quot;Handling the first &quot; + misfiredTriggers.size() +</span>
                &quot; triggers that missed their scheduled fire-time.  &quot; +
                &quot;More misfired triggers remain to be processed.&quot;);
<span class="fc bfc" id="L972" title="All 2 branches covered.">        } else if (misfiredTriggers.size() &gt; 0) { </span>
<span class="fc" id="L973">            getLog().info(</span>
<span class="fc" id="L974">                &quot;Handling &quot; + misfiredTriggers.size() + </span>
                &quot; trigger(s) that missed their scheduled fire-time.&quot;);
        } else {
<span class="fc" id="L977">            getLog().debug(</span>
                &quot;Found 0 triggers that missed their scheduled fire-time.&quot;);
<span class="fc" id="L979">            return RecoverMisfiredJobsResult.NO_OP; </span>
        }

<span class="fc bfc" id="L982" title="All 2 branches covered.">        for (TriggerKey triggerKey: misfiredTriggers) {</span>
            
<span class="fc" id="L984">            OperableTrigger trig = </span>
<span class="fc" id="L985">                retrieveTrigger(conn, triggerKey);</span>

<span class="pc bpc" id="L987" title="1 of 2 branches missed.">            if (trig == null) {</span>
<span class="nc" id="L988">                continue;</span>
            }

<span class="fc" id="L991">            doUpdateOfMisfiredTrigger(conn, trig, false, STATE_WAITING, recovering);</span>

<span class="pc bpc" id="L993" title="1 of 4 branches missed.">            if(trig.getNextFireTime() != null &amp;&amp; trig.getNextFireTime().getTime() &lt; earliestNewTime)</span>
<span class="fc" id="L994">                earliestNewTime = trig.getNextFireTime().getTime();</span>
<span class="fc" id="L995">        }</span>

<span class="fc" id="L997">        return new RecoverMisfiredJobsResult(</span>
<span class="fc" id="L998">                hasMoreMisfiredTriggers, misfiredTriggers.size(), earliestNewTime);</span>
    }

    protected boolean updateMisfiredTrigger(Connection conn,
            TriggerKey triggerKey, String newStateIfNotComplete, boolean forceState)
        throws JobPersistenceException {
        try {

<span class="fc" id="L1006">            OperableTrigger trig = retrieveTrigger(conn, triggerKey);</span>

<span class="fc" id="L1008">            long misfireTime = System.currentTimeMillis();</span>
<span class="pc bpc" id="L1009" title="1 of 2 branches missed.">            if (getMisfireThreshold() &gt; 0) {</span>
<span class="fc" id="L1010">                misfireTime -= getMisfireThreshold();</span>
            }

<span class="pc bpc" id="L1013" title="1 of 2 branches missed.">            if (trig.getNextFireTime().getTime() &gt; misfireTime) {</span>
<span class="fc" id="L1014">                return false;</span>
            }

<span class="nc" id="L1017">            doUpdateOfMisfiredTrigger(conn, trig, forceState, newStateIfNotComplete, false);</span>

<span class="nc" id="L1019">            return true;</span>

<span class="nc" id="L1021">        } catch (Exception e) {</span>
<span class="nc" id="L1022">            throw new JobPersistenceException(</span>
<span class="nc" id="L1023">                    &quot;Couldn't update misfired trigger '&quot; + triggerKey + &quot;': &quot; + e.getMessage(), e);</span>
        }
    }

    private void doUpdateOfMisfiredTrigger(Connection conn, OperableTrigger trig, boolean forceState, String newStateIfNotComplete, boolean recovering) throws JobPersistenceException {
<span class="fc" id="L1028">        Calendar cal = null;</span>
<span class="pc bpc" id="L1029" title="1 of 2 branches missed.">        if (trig.getCalendarName() != null) {</span>
<span class="nc" id="L1030">            cal = retrieveCalendar(conn, trig.getCalendarName());</span>
        }

<span class="fc" id="L1033">        schedSignaler.notifyTriggerListenersMisfired(trig);</span>

<span class="fc" id="L1035">        trig.updateAfterMisfire(cal);</span>

<span class="pc bpc" id="L1037" title="1 of 2 branches missed.">        if (trig.getNextFireTime() == null) {</span>
<span class="nc" id="L1038">            storeTrigger(conn, trig,</span>
                null, true, STATE_COMPLETE, forceState, recovering);
<span class="nc" id="L1040">            schedSignaler.notifySchedulerListenersFinalized(trig);</span>
        } else {
<span class="fc" id="L1042">            storeTrigger(conn, trig, null, true, newStateIfNotComplete,</span>
                    forceState, recovering);
        }
<span class="fc" id="L1045">    }</span>

    /**
     * &lt;p&gt;
     * Store the given &lt;code&gt;{@link org.quartz.JobDetail}&lt;/code&gt; and &lt;code&gt;{@link org.quartz.Trigger}&lt;/code&gt;.
     * &lt;/p&gt;
     * 
     * @param newJob
     *          The &lt;code&gt;JobDetail&lt;/code&gt; to be stored.
     * @param newTrigger
     *          The &lt;code&gt;Trigger&lt;/code&gt; to be stored.
     * @throws ObjectAlreadyExistsException
     *           if a &lt;code&gt;Job&lt;/code&gt; with the same name/group already
     *           exists.
     */
    public void storeJobAndTrigger(final JobDetail newJob,
            final OperableTrigger newTrigger) 
        throws JobPersistenceException {
<span class="fc" id="L1063">        executeInLock(</span>
<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">            (isLockOnInsert()) ? LOCK_TRIGGER_ACCESS : null,</span>
<span class="fc" id="L1065">            new VoidTransactionCallback() {</span>
                public void executeVoid(Connection conn) throws JobPersistenceException {
<span class="fc" id="L1067">                    storeJob(conn, newJob, false);</span>
<span class="fc" id="L1068">                    storeTrigger(conn, newTrigger, newJob, false,</span>
                            Constants.STATE_WAITING, false, false);
<span class="fc" id="L1070">                }</span>
            });
<span class="fc" id="L1072">    }</span>
    
    /**
     * &lt;p&gt;
     * Store the given &lt;code&gt;{@link org.quartz.JobDetail}&lt;/code&gt;.
     * &lt;/p&gt;
     * 
     * @param newJob
     *          The &lt;code&gt;JobDetail&lt;/code&gt; to be stored.
     * @param replaceExisting
     *          If &lt;code&gt;true&lt;/code&gt;, any &lt;code&gt;Job&lt;/code&gt; existing in the
     *          &lt;code&gt;JobStore&lt;/code&gt; with the same name &amp; group should be
     *          over-written.
     * @throws ObjectAlreadyExistsException
     *           if a &lt;code&gt;Job&lt;/code&gt; with the same name/group already
     *           exists, and replaceExisting is set to false.
     */
    public void storeJob(final JobDetail newJob,
        final boolean replaceExisting) throws JobPersistenceException {
<span class="fc" id="L1091">        executeInLock(</span>
<span class="pc bpc" id="L1092" title="3 of 4 branches missed.">            (isLockOnInsert() || replaceExisting) ? LOCK_TRIGGER_ACCESS : null,</span>
<span class="fc" id="L1093">            new VoidTransactionCallback() {</span>
                public void executeVoid(Connection conn) throws JobPersistenceException {
<span class="fc" id="L1095">                    storeJob(conn, newJob, replaceExisting);</span>
<span class="fc" id="L1096">                }</span>
            });
<span class="fc" id="L1098">    }</span>
    
    /**
     * &lt;p&gt;
     * Insert or update a job.
     * &lt;/p&gt;
     */
    protected void storeJob(Connection conn, 
            JobDetail newJob, boolean replaceExisting)
        throws JobPersistenceException {

<span class="fc" id="L1109">        boolean existingJob = jobExists(conn, newJob.getKey());</span>
        try {
<span class="fc bfc" id="L1111" title="All 2 branches covered.">            if (existingJob) {</span>
<span class="pc bpc" id="L1112" title="1 of 2 branches missed.">                if (!replaceExisting) { </span>
<span class="nc" id="L1113">                    throw new ObjectAlreadyExistsException(newJob); </span>
                }
<span class="fc" id="L1115">                getDelegate().updateJobDetail(conn, newJob);</span>
            } else {
<span class="fc" id="L1117">                getDelegate().insertJobDetail(conn, newJob);</span>
            }
<span class="nc" id="L1119">        } catch (IOException e) {</span>
<span class="nc" id="L1120">            throw new JobPersistenceException(&quot;Couldn't store job: &quot;</span>
<span class="nc" id="L1121">                    + e.getMessage(), e);</span>
<span class="nc" id="L1122">        } catch (SQLException e) {</span>
<span class="nc" id="L1123">            throw new JobPersistenceException(&quot;Couldn't store job: &quot;</span>
<span class="nc" id="L1124">                    + e.getMessage(), e);</span>
<span class="fc" id="L1125">        }</span>
<span class="fc" id="L1126">    }</span>

    /**
     * &lt;p&gt;
     * Check existence of a given job.
     * &lt;/p&gt;
     */
    protected boolean jobExists(Connection conn, JobKey jobKey) throws JobPersistenceException {
        try {
<span class="fc" id="L1135">            return getDelegate().jobExists(conn, jobKey);</span>
<span class="nc" id="L1136">        } catch (SQLException e) {</span>
<span class="nc" id="L1137">            throw new JobPersistenceException(</span>
<span class="nc" id="L1138">                    &quot;Couldn't determine job existence (&quot; + jobKey + &quot;): &quot; + e.getMessage(), e);</span>
        }
    }


    /**
     * &lt;p&gt;
     * Store the given &lt;code&gt;{@link org.quartz.Trigger}&lt;/code&gt;.
     * &lt;/p&gt;
     * 
     * @param newTrigger
     *          The &lt;code&gt;Trigger&lt;/code&gt; to be stored.
     * @param replaceExisting
     *          If &lt;code&gt;true&lt;/code&gt;, any &lt;code&gt;Trigger&lt;/code&gt; existing in
     *          the &lt;code&gt;JobStore&lt;/code&gt; with the same name &amp; group should
     *          be over-written.
     * @throws ObjectAlreadyExistsException
     *           if a &lt;code&gt;Trigger&lt;/code&gt; with the same name/group already
     *           exists, and replaceExisting is set to false.
     */
    public void storeTrigger(final OperableTrigger newTrigger,
        final boolean replaceExisting) throws JobPersistenceException {
<span class="fc" id="L1160">        executeInLock(</span>
<span class="pc bpc" id="L1161" title="3 of 4 branches missed.">            (isLockOnInsert() || replaceExisting) ? LOCK_TRIGGER_ACCESS : null,</span>
<span class="fc" id="L1162">            new VoidTransactionCallback() {</span>
                public void executeVoid(Connection conn) throws JobPersistenceException {
<span class="fc" id="L1164">                    storeTrigger(conn, newTrigger, null, replaceExisting,</span>
                        STATE_WAITING, false, false);
<span class="fc" id="L1166">                }</span>
            });
<span class="fc" id="L1168">    }</span>
    
    /**
     * &lt;p&gt;
     * Insert or update a trigger.
     * &lt;/p&gt;
     */
    @SuppressWarnings(&quot;ConstantConditions&quot;)
    protected void storeTrigger(Connection conn,
            OperableTrigger newTrigger, JobDetail job, boolean replaceExisting, String state,
            boolean forceState, boolean recovering)
        throws JobPersistenceException {

<span class="fc" id="L1181">        boolean existingTrigger = triggerExists(conn, newTrigger.getKey());</span>

<span class="fc bfc" id="L1183" title="All 4 branches covered.">        if ((existingTrigger) &amp;&amp; (!replaceExisting)) { </span>
<span class="fc" id="L1184">            throw new ObjectAlreadyExistsException(newTrigger); </span>
        }
        
        try {

            boolean shouldBepaused;

<span class="fc bfc" id="L1191" title="All 2 branches covered.">            if (!forceState) {</span>
<span class="fc" id="L1192">                shouldBepaused = getDelegate().isTriggerGroupPaused(</span>
<span class="fc" id="L1193">                        conn, newTrigger.getKey().getGroup());</span>

<span class="fc bfc" id="L1195" title="All 2 branches covered.">                if(!shouldBepaused) {</span>
<span class="fc" id="L1196">                    shouldBepaused = getDelegate().isTriggerGroupPaused(conn,</span>
                            ALL_GROUPS_PAUSED);

<span class="pc bpc" id="L1199" title="1 of 2 branches missed.">                    if (shouldBepaused) {</span>
<span class="nc" id="L1200">                        getDelegate().insertPausedTriggerGroup(conn, newTrigger.getKey().getGroup());</span>
                    }
                }

<span class="pc bpc" id="L1204" title="3 of 6 branches missed.">                if (shouldBepaused &amp;&amp; (state.equals(STATE_WAITING) || state.equals(STATE_ACQUIRED))) {</span>
<span class="fc" id="L1205">                    state = STATE_PAUSED;</span>
                }
            }

<span class="fc bfc" id="L1209" title="All 2 branches covered.">            if(job == null) {</span>
<span class="fc" id="L1210">                job = retrieveJob(conn, newTrigger.getJobKey());</span>
            }
<span class="pc bpc" id="L1212" title="1 of 2 branches missed.">            if (job == null) {</span>
<span class="nc" id="L1213">                throw new JobPersistenceException(&quot;The job (&quot;</span>
<span class="nc" id="L1214">                        + newTrigger.getJobKey()</span>
                        + &quot;) referenced by the trigger does not exist.&quot;);
            }

<span class="fc bfc" id="L1218" title="All 4 branches covered.">            if (job.isConcurrentExectionDisallowed() &amp;&amp; !recovering) { </span>
<span class="fc" id="L1219">                state = checkBlockedState(conn, job.getKey(), state);</span>
            }
            
<span class="fc bfc" id="L1222" title="All 2 branches covered.">            if (existingTrigger) {</span>
<span class="fc" id="L1223">                getDelegate().updateTrigger(conn, newTrigger, state, job);</span>
            } else {
<span class="fc" id="L1225">                getDelegate().insertTrigger(conn, newTrigger, state, job);</span>
            }
<span class="nc" id="L1227">        } catch (Exception e) {</span>
<span class="nc" id="L1228">            throw new JobPersistenceException(&quot;Couldn't store trigger '&quot; + newTrigger.getKey() + &quot;' for '&quot; </span>
<span class="nc" id="L1229">                    + newTrigger.getJobKey() + &quot;' job:&quot; + e.getMessage(), e);</span>
<span class="fc" id="L1230">        }</span>
<span class="fc" id="L1231">    }</span>

    /**
     * &lt;p&gt;
     * Check existence of a given trigger.
     * &lt;/p&gt;
     */
    protected boolean triggerExists(Connection conn, TriggerKey key) throws JobPersistenceException {
        try {
<span class="fc" id="L1240">            return getDelegate().triggerExists(conn, key);</span>
<span class="nc" id="L1241">        } catch (SQLException e) {</span>
<span class="nc" id="L1242">            throw new JobPersistenceException(</span>
<span class="nc" id="L1243">                    &quot;Couldn't determine trigger existence (&quot; + key + &quot;): &quot; + e.getMessage(), e);</span>
        }
    }

    /**
     * &lt;p&gt;
     * Remove (delete) the &lt;code&gt;{@link org.quartz.Job}&lt;/code&gt; with the given
     * name, and any &lt;code&gt;{@link org.quartz.Trigger}&lt;/code&gt; s that reference
     * it.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If removal of the &lt;code&gt;Job&lt;/code&gt; results in an empty group, the
     * group should be removed from the &lt;code&gt;JobStore&lt;/code&gt;'s list of
     * known group names.
     * &lt;/p&gt;
     * 
     * @return &lt;code&gt;true&lt;/code&gt; if a &lt;code&gt;Job&lt;/code&gt; with the given name &amp;
     *         group was found and removed from the store.
     */
    public boolean removeJob(final JobKey jobKey) throws JobPersistenceException {
<span class="fc" id="L1264">        return (Boolean) executeInLock(</span>
                LOCK_TRIGGER_ACCESS,
<span class="fc" id="L1266">                new TransactionCallback() {</span>
                    public Object execute(Connection conn) throws JobPersistenceException {
<span class="fc bfc" id="L1268" title="All 2 branches covered.">                        return removeJob(conn, jobKey) ?</span>
                                Boolean.TRUE : Boolean.FALSE;
                    }
                });
    }
    
    protected boolean removeJob(Connection conn, final JobKey jobKey)
        throws JobPersistenceException {

        try {
<span class="fc" id="L1278">            List&lt;TriggerKey&gt; jobTriggers = getDelegate().selectTriggerKeysForJob(conn, jobKey);</span>
<span class="fc bfc" id="L1279" title="All 2 branches covered.">            for (TriggerKey jobTrigger: jobTriggers) {</span>
<span class="fc" id="L1280">                deleteTriggerAndChildren(conn, jobTrigger);</span>
<span class="fc" id="L1281">            }</span>

<span class="fc" id="L1283">            return deleteJobAndChildren(conn, jobKey);</span>
<span class="nc" id="L1284">        } catch (SQLException e) {</span>
<span class="nc" id="L1285">            throw new JobPersistenceException(&quot;Couldn't remove job: &quot;</span>
<span class="nc" id="L1286">                    + e.getMessage(), e);</span>
        }
    }

    public boolean removeJobs(final List&lt;JobKey&gt; jobKeys) throws JobPersistenceException {

<span class="nc" id="L1292">        return (Boolean) executeInLock(</span>
                LOCK_TRIGGER_ACCESS,
<span class="nc" id="L1294">                new TransactionCallback() {</span>
                    public Object execute(Connection conn) throws JobPersistenceException {
<span class="nc" id="L1296">                        boolean allFound = true;</span>

                        // FUTURE_TODO: make this more efficient with a true bulk operation...
<span class="nc bnc" id="L1299" title="All 2 branches missed.">                        for (JobKey jobKey : jobKeys)</span>
<span class="nc bnc" id="L1300" title="All 4 branches missed.">                            allFound = removeJob(conn, jobKey) &amp;&amp; allFound;</span>

<span class="nc bnc" id="L1302" title="All 2 branches missed.">                        return allFound ? Boolean.TRUE : Boolean.FALSE;</span>
                    }
                });
    }
        
    public boolean removeTriggers(final List&lt;TriggerKey&gt; triggerKeys)
            throws JobPersistenceException {
<span class="nc" id="L1309">        return (Boolean) executeInLock(</span>
                LOCK_TRIGGER_ACCESS,
<span class="nc" id="L1311">                new TransactionCallback() {</span>
                    public Object execute(Connection conn) throws JobPersistenceException {
<span class="nc" id="L1313">                        boolean allFound = true;</span>

                        // FUTURE_TODO: make this more efficient with a true bulk operation...
<span class="nc bnc" id="L1316" title="All 2 branches missed.">                        for (TriggerKey triggerKey : triggerKeys)</span>
<span class="nc bnc" id="L1317" title="All 4 branches missed.">                            allFound = removeTrigger(conn, triggerKey) &amp;&amp; allFound;</span>

<span class="nc bnc" id="L1319" title="All 2 branches missed.">                        return allFound ? Boolean.TRUE : Boolean.FALSE;</span>
                    }
                });
    }
        
    public void storeJobsAndTriggers(
            final Map&lt;JobDetail, Set&lt;? extends Trigger&gt;&gt; triggersAndJobs, final boolean replace)
            throws JobPersistenceException {

<span class="fc" id="L1328">        executeInLock(</span>
<span class="pc bpc" id="L1329" title="3 of 4 branches missed.">                (isLockOnInsert() || replace) ? LOCK_TRIGGER_ACCESS : null,</span>
<span class="fc" id="L1330">                new VoidTransactionCallback() {</span>
                    public void executeVoid(Connection conn) throws JobPersistenceException {
                        
                        // FUTURE_TODO: make this more efficient with a true bulk operation...
<span class="fc bfc" id="L1334" title="All 2 branches covered.">                        for(JobDetail job: triggersAndJobs.keySet()) {</span>
<span class="fc" id="L1335">                            storeJob(conn, job, replace);</span>
<span class="fc bfc" id="L1336" title="All 2 branches covered.">                            for(Trigger trigger: triggersAndJobs.get(job)) {</span>
<span class="fc" id="L1337">                                storeTrigger(conn, (OperableTrigger) trigger, job, replace,</span>
                                        Constants.STATE_WAITING, false, false);
<span class="fc" id="L1339">                            }</span>
<span class="fc" id="L1340">                        }</span>
<span class="fc" id="L1341">                    }</span>
                });
<span class="fc" id="L1343">    }    </span>
    
    /**
     * Delete a job and its listeners.
     * 
     * @see #removeJob(java.sql.Connection, org.quartz.JobKey)
     * @see #removeTrigger(Connection, TriggerKey)
     */
    private boolean deleteJobAndChildren(Connection conn, JobKey key)
        throws NoSuchDelegateException, SQLException {

<span class="fc bfc" id="L1354" title="All 2 branches covered.">        return (getDelegate().deleteJobDetail(conn, key) &gt; 0);</span>
    }
    
    /**
     * Delete a trigger, its listeners, and its Simple/Cron/BLOB sub-table entry.
     * 
     * @see #removeJob(java.sql.Connection, org.quartz.JobKey)
     * @see #removeTrigger(Connection, TriggerKey)
     * @see #replaceTrigger(Connection, TriggerKey, OperableTrigger)
     */
    private boolean deleteTriggerAndChildren(Connection conn, TriggerKey key)
        throws SQLException, NoSuchDelegateException {

<span class="fc bfc" id="L1367" title="All 2 branches covered.">        return (getDelegate().deleteTrigger(conn, key) &gt; 0);</span>
    }
    
    /**
     * &lt;p&gt;
     * Retrieve the &lt;code&gt;{@link org.quartz.JobDetail}&lt;/code&gt; for the given
     * &lt;code&gt;{@link org.quartz.Job}&lt;/code&gt;.
     * &lt;/p&gt;
     * 
     * @return The desired &lt;code&gt;Job&lt;/code&gt;, or null if there is no match.
     */
    public JobDetail retrieveJob(final JobKey jobKey) throws JobPersistenceException {
<span class="fc" id="L1379">        return (JobDetail)executeWithoutLock( // no locks necessary for read...</span>
<span class="fc" id="L1380">            new TransactionCallback() {</span>
                public Object execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L1382">                    return retrieveJob(conn, jobKey);</span>
                }
            });
    }
    
    protected JobDetail retrieveJob(Connection conn, JobKey key) throws JobPersistenceException {
        try {

<span class="fc" id="L1390">            return getDelegate().selectJobDetail(conn, key,</span>
<span class="fc" id="L1391">                    getClassLoadHelper());</span>
<span class="fc" id="L1392">        } catch (ClassNotFoundException e) {</span>
<span class="fc" id="L1393">            throw new JobPersistenceException(</span>
                    &quot;Couldn't retrieve job because a required class was not found: &quot;
<span class="fc" id="L1395">                            + e.getMessage(), e);</span>
<span class="nc" id="L1396">        } catch (IOException e) {</span>
<span class="nc" id="L1397">            throw new JobPersistenceException(</span>
                    &quot;Couldn't retrieve job because the BLOB couldn't be deserialized: &quot;
<span class="nc" id="L1399">                            + e.getMessage(), e);</span>
<span class="nc" id="L1400">        } catch (SQLException e) {</span>
<span class="nc" id="L1401">            throw new JobPersistenceException(&quot;Couldn't retrieve job: &quot;</span>
<span class="nc" id="L1402">                    + e.getMessage(), e);</span>
        }
    }

    /**
     * &lt;p&gt;
     * Remove (delete) the &lt;code&gt;{@link org.quartz.Trigger}&lt;/code&gt; with the
     * given name.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If removal of the &lt;code&gt;Trigger&lt;/code&gt; results in an empty group, the
     * group should be removed from the &lt;code&gt;JobStore&lt;/code&gt;'s list of
     * known group names.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If removal of the &lt;code&gt;Trigger&lt;/code&gt; results in an 'orphaned' &lt;code&gt;Job&lt;/code&gt;
     * that is not 'durable', then the &lt;code&gt;Job&lt;/code&gt; should be deleted
     * also.
     * &lt;/p&gt;
     * 
     * @return &lt;code&gt;true&lt;/code&gt; if a &lt;code&gt;Trigger&lt;/code&gt; with the given
     *         name &amp; group was found and removed from the store.
     */
    public boolean removeTrigger(final TriggerKey triggerKey) throws JobPersistenceException {
<span class="fc" id="L1428">        return (Boolean) executeInLock(</span>
                LOCK_TRIGGER_ACCESS,
<span class="fc" id="L1430">                new TransactionCallback() {</span>
                    public Object execute(Connection conn) throws JobPersistenceException {
<span class="fc bfc" id="L1432" title="All 2 branches covered.">                        return removeTrigger(conn, triggerKey) ?</span>
                                Boolean.TRUE : Boolean.FALSE;
                    }
                });
    }
    
    protected boolean removeTrigger(Connection conn, TriggerKey key)
        throws JobPersistenceException {
        boolean removedTrigger;
        try {
            // this must be called before we delete the trigger, obviously
<span class="fc" id="L1443">            JobDetail job = getDelegate().selectJobForTrigger(conn,</span>
<span class="fc" id="L1444">                    getClassLoadHelper(), key, false);</span>

<span class="fc" id="L1446">            removedTrigger = </span>
<span class="fc" id="L1447">                deleteTriggerAndChildren(conn, key);</span>

<span class="fc bfc" id="L1449" title="All 4 branches covered.">            if (null != job &amp;&amp; !job.isDurable()) {</span>
<span class="fc" id="L1450">                int numTriggers = getDelegate().selectNumTriggersForJob(conn,</span>
<span class="fc" id="L1451">                        job.getKey());</span>
<span class="pc bpc" id="L1452" title="1 of 2 branches missed.">                if (numTriggers == 0) {</span>
                    // Don't call removeJob() because we don't want to check for
                    // triggers again.
<span class="fc" id="L1455">                    deleteJobAndChildren(conn, job.getKey());</span>
                }
            }
<span class="nc" id="L1458">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L1459">            throw new JobPersistenceException(&quot;Couldn't remove trigger: &quot;</span>
<span class="nc" id="L1460">                    + e.getMessage(), e);</span>
<span class="nc" id="L1461">        } catch (SQLException e) {</span>
<span class="nc" id="L1462">            throw new JobPersistenceException(&quot;Couldn't remove trigger: &quot;</span>
<span class="nc" id="L1463">                    + e.getMessage(), e);</span>
<span class="fc" id="L1464">        }</span>

<span class="fc" id="L1466">        return removedTrigger;</span>
    }

    /** 
     * @see org.quartz.spi.JobStore#replaceTrigger(TriggerKey, OperableTrigger)
     */
    public boolean replaceTrigger(final TriggerKey triggerKey, 
            final OperableTrigger newTrigger) throws JobPersistenceException {
<span class="nc" id="L1474">        return (Boolean) executeInLock(</span>
                LOCK_TRIGGER_ACCESS,
<span class="nc" id="L1476">                new TransactionCallback() {</span>
                    public Object execute(Connection conn) throws JobPersistenceException {
<span class="nc bnc" id="L1478" title="All 2 branches missed.">                        return replaceTrigger(conn, triggerKey, newTrigger) ?</span>
                                Boolean.TRUE : Boolean.FALSE;
                    }
                });
    }
    
    protected boolean replaceTrigger(Connection conn, 
            TriggerKey key, OperableTrigger newTrigger)
        throws JobPersistenceException {
        try {
            // this must be called before we delete the trigger, obviously
<span class="nc" id="L1489">            JobDetail job = getDelegate().selectJobForTrigger(conn,</span>
<span class="nc" id="L1490">                    getClassLoadHelper(), key);</span>

<span class="nc bnc" id="L1492" title="All 2 branches missed.">            if (job == null) {</span>
<span class="nc" id="L1493">                return false;</span>
            }
            
<span class="nc bnc" id="L1496" title="All 2 branches missed.">            if (!newTrigger.getJobKey().equals(job.getKey())) {</span>
<span class="nc" id="L1497">                throw new JobPersistenceException(&quot;New trigger is not related to the same job as the old trigger.&quot;);</span>
            }
            
<span class="nc" id="L1500">            boolean removedTrigger = </span>
<span class="nc" id="L1501">                deleteTriggerAndChildren(conn, key);</span>
            
<span class="nc" id="L1503">            storeTrigger(conn, newTrigger, job, false, STATE_WAITING, false, false);</span>

<span class="nc" id="L1505">            return removedTrigger;</span>
<span class="nc" id="L1506">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L1507">            throw new JobPersistenceException(&quot;Couldn't remove trigger: &quot;</span>
<span class="nc" id="L1508">                    + e.getMessage(), e);</span>
<span class="nc" id="L1509">        } catch (SQLException e) {</span>
<span class="nc" id="L1510">            throw new JobPersistenceException(&quot;Couldn't remove trigger: &quot;</span>
<span class="nc" id="L1511">                    + e.getMessage(), e);</span>
        }
    }

    /**
     * &lt;p&gt;
     * Retrieve the given &lt;code&gt;{@link org.quartz.Trigger}&lt;/code&gt;.
     * &lt;/p&gt;
     * 
     * @return The desired &lt;code&gt;Trigger&lt;/code&gt;, or null if there is no
     *         match.
     */
    public OperableTrigger retrieveTrigger(final TriggerKey triggerKey) throws JobPersistenceException {
<span class="fc" id="L1524">        return (OperableTrigger)executeWithoutLock( // no locks necessary for read...</span>
<span class="fc" id="L1525">            new TransactionCallback() {</span>
                public Object execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L1527">                    return retrieveTrigger(conn, triggerKey);</span>
                }
            });
    }
    
    protected OperableTrigger retrieveTrigger(Connection conn, TriggerKey key)
        throws JobPersistenceException {
        try {

<span class="fc" id="L1536">            return getDelegate().selectTrigger(conn, key);</span>
<span class="nc" id="L1537">        } catch (Exception e) {</span>
<span class="nc" id="L1538">            throw new JobPersistenceException(&quot;Couldn't retrieve trigger: &quot;</span>
<span class="nc" id="L1539">                    + e.getMessage(), e);</span>
        }
    }

    /**
     * &lt;p&gt;
     * Get the current state of the identified &lt;code&gt;{@link Trigger}&lt;/code&gt;.
     * &lt;/p&gt;
     * 
     * @see TriggerState#NORMAL
     * @see TriggerState#PAUSED
     * @see TriggerState#COMPLETE
     * @see TriggerState#ERROR
     * @see TriggerState#NONE
     */
    public TriggerState getTriggerState(final TriggerKey triggerKey) throws JobPersistenceException {
<span class="fc" id="L1555">        return (TriggerState)executeWithoutLock( // no locks necessary for read...</span>
<span class="fc" id="L1556">                new TransactionCallback() {</span>
                    public Object execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L1558">                        return getTriggerState(conn, triggerKey);</span>
                    }
                });
    }
    
    public TriggerState getTriggerState(Connection conn, TriggerKey key)
        throws JobPersistenceException {
        try {
<span class="fc" id="L1566">            String ts = getDelegate().selectTriggerState(conn, key);</span>

<span class="pc bpc" id="L1568" title="1 of 2 branches missed.">            if (ts == null) {</span>
<span class="nc" id="L1569">                return TriggerState.NONE;</span>
            }

<span class="fc bfc" id="L1572" title="All 2 branches covered.">            if (ts.equals(STATE_DELETED)) {</span>
<span class="fc" id="L1573">                return TriggerState.NONE;</span>
            }

<span class="pc bpc" id="L1576" title="1 of 2 branches missed.">            if (ts.equals(STATE_COMPLETE)) {</span>
<span class="nc" id="L1577">                return TriggerState.COMPLETE;</span>
            }

<span class="fc bfc" id="L1580" title="All 2 branches covered.">            if (ts.equals(STATE_PAUSED)) {</span>
<span class="fc" id="L1581">                return TriggerState.PAUSED;</span>
            }

<span class="pc bpc" id="L1584" title="1 of 2 branches missed.">            if (ts.equals(STATE_PAUSED_BLOCKED)) {</span>
<span class="nc" id="L1585">                return TriggerState.PAUSED;</span>
            }

<span class="fc bfc" id="L1588" title="All 2 branches covered.">            if (ts.equals(STATE_ERROR)) {</span>
<span class="fc" id="L1589">                return TriggerState.ERROR;</span>
            }

<span class="pc bpc" id="L1592" title="1 of 2 branches missed.">            if (ts.equals(STATE_BLOCKED)) {</span>
<span class="nc" id="L1593">                return TriggerState.BLOCKED;</span>
            }

<span class="fc" id="L1596">            return TriggerState.NORMAL;</span>

<span class="nc" id="L1598">        } catch (SQLException e) {</span>
<span class="nc" id="L1599">            throw new JobPersistenceException(</span>
<span class="nc" id="L1600">                    &quot;Couldn't determine state of trigger (&quot; + key + &quot;): &quot; + e.getMessage(), e);</span>
        }
    }

    /**
     * Reset the current state of the identified &lt;code&gt;{@link Trigger}&lt;/code&gt;
     * from {@link TriggerState#ERROR} to {@link TriggerState#NORMAL} or
     * {@link TriggerState#PAUSED} as appropriate.
     *
     * &lt;p&gt;Only affects triggers that are in ERROR state - if identified trigger is not
     * in that state then the result is a no-op.&lt;/p&gt;
     *
     * &lt;p&gt;The result will be the trigger returning to the normal, waiting to
     * be fired state, unless the trigger's group has been paused, in which
     * case it will go into the PAUSED state.&lt;/p&gt;
     */
    public void resetTriggerFromErrorState(final TriggerKey triggerKey) throws JobPersistenceException {
<span class="fc" id="L1617">        executeInLock(</span>
                LOCK_TRIGGER_ACCESS,
<span class="fc" id="L1619">                new VoidTransactionCallback() {</span>
                    public void executeVoid(Connection conn) throws JobPersistenceException {
<span class="fc" id="L1621">                        resetTriggerFromErrorState(conn, triggerKey);</span>
<span class="fc" id="L1622">                    }</span>
                });
<span class="fc" id="L1624">    }</span>

    void resetTriggerFromErrorState(Connection conn, final TriggerKey triggerKey)
        throws JobPersistenceException {

        try {
<span class="fc" id="L1630">            String newState = STATE_WAITING;</span>

<span class="pc bpc" id="L1632" title="1 of 2 branches missed.">            if(getDelegate().isTriggerGroupPaused(conn, triggerKey.getGroup())) {</span>
<span class="nc" id="L1633">                newState = STATE_PAUSED;</span>
            }

<span class="fc" id="L1636">            getDelegate().updateTriggerStateFromOtherState(conn, triggerKey, newState, STATE_ERROR);</span>

<span class="fc" id="L1638">            getLog().info(&quot;Trigger &quot; + triggerKey + &quot; reset from ERROR state to: &quot; + newState);</span>
<span class="nc" id="L1639">        } catch (SQLException e) {</span>
<span class="nc" id="L1640">            throw new JobPersistenceException(</span>
<span class="nc" id="L1641">                    &quot;Couldn't reset from error state of trigger (&quot; + triggerKey + &quot;): &quot; + e.getMessage(), e);</span>
<span class="fc" id="L1642">        }</span>
<span class="fc" id="L1643">    }</span>

    /**
     * &lt;p&gt;
     * Store the given &lt;code&gt;{@link org.quartz.Calendar}&lt;/code&gt;.
     * &lt;/p&gt;
     * 
     * @param calName
     *          The name of the calendar.
     * @param calendar
     *          The &lt;code&gt;Calendar&lt;/code&gt; to be stored.
     * @param replaceExisting
     *          If &lt;code&gt;true&lt;/code&gt;, any &lt;code&gt;Calendar&lt;/code&gt; existing
     *          in the &lt;code&gt;JobStore&lt;/code&gt; with the same name &amp; group
     *          should be over-written.
     * @throws ObjectAlreadyExistsException
     *           if a &lt;code&gt;Calendar&lt;/code&gt; with the same name already
     *           exists, and replaceExisting is set to false.
     */
    public void storeCalendar(final String calName,
        final Calendar calendar, final boolean replaceExisting, final boolean updateTriggers)
        throws JobPersistenceException {
<span class="nc" id="L1665">        executeInLock(</span>
<span class="nc bnc" id="L1666" title="All 4 branches missed.">            (isLockOnInsert() || updateTriggers) ? LOCK_TRIGGER_ACCESS : null,</span>
<span class="nc" id="L1667">            new VoidTransactionCallback() {</span>
                public void executeVoid(Connection conn) throws JobPersistenceException {
<span class="nc" id="L1669">                    storeCalendar(conn, calName, calendar, replaceExisting, updateTriggers);</span>
<span class="nc" id="L1670">                }</span>
            });
<span class="nc" id="L1672">    }</span>
    
    protected void storeCalendar(Connection conn, 
            String calName, Calendar calendar, boolean replaceExisting, boolean updateTriggers)
        throws JobPersistenceException {
        try {
<span class="nc" id="L1678">            boolean existingCal = calendarExists(conn, calName);</span>
<span class="nc bnc" id="L1679" title="All 4 branches missed.">            if (existingCal &amp;&amp; !replaceExisting) { </span>
<span class="nc" id="L1680">                throw new ObjectAlreadyExistsException(</span>
                    &quot;Calendar with name '&quot; + calName + &quot;' already exists.&quot;); 
            }

<span class="nc bnc" id="L1684" title="All 2 branches missed.">            if (existingCal) {</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">                if (getDelegate().updateCalendar(conn, calName, calendar) &lt; 1) { </span>
<span class="nc" id="L1686">                    throw new JobPersistenceException(</span>
                        &quot;Couldn't store calendar.  Update failed.&quot;); 
                }
                
<span class="nc bnc" id="L1690" title="All 2 branches missed.">                if(updateTriggers) {</span>
<span class="nc" id="L1691">                    List&lt;OperableTrigger&gt; trigs = getDelegate().selectTriggersForCalendar(conn, calName);</span>
                    
<span class="nc bnc" id="L1693" title="All 2 branches missed.">                    for(OperableTrigger trigger: trigs) {</span>
<span class="nc" id="L1694">                        trigger.updateWithNewCalendar(calendar, getMisfireThreshold());</span>
<span class="nc" id="L1695">                        storeTrigger(conn, trigger, null, true, STATE_WAITING, false, false);</span>
<span class="nc" id="L1696">                    }</span>
<span class="nc" id="L1697">                }</span>
            } else {
<span class="nc bnc" id="L1699" title="All 2 branches missed.">                if (getDelegate().insertCalendar(conn, calName, calendar) &lt; 1) { </span>
<span class="nc" id="L1700">                    throw new JobPersistenceException(</span>
                        &quot;Couldn't store calendar.  Insert failed.&quot;); 
                }
            }

<span class="nc bnc" id="L1705" title="All 2 branches missed.">            if (!isClustered) {</span>
<span class="nc" id="L1706">                calendarCache.put(calName, calendar); // lazy-cache</span>
            }

<span class="nc" id="L1709">        } catch (IOException e) {</span>
<span class="nc" id="L1710">            throw new JobPersistenceException(</span>
                    &quot;Couldn't store calendar because the BLOB couldn't be serialized: &quot;
<span class="nc" id="L1712">                            + e.getMessage(), e);</span>
<span class="nc" id="L1713">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L1714">            throw new JobPersistenceException(&quot;Couldn't store calendar: &quot;</span>
<span class="nc" id="L1715">                    + e.getMessage(), e);</span>
<span class="nc" id="L1716">        }catch (SQLException e) {</span>
<span class="nc" id="L1717">            throw new JobPersistenceException(&quot;Couldn't store calendar: &quot;</span>
<span class="nc" id="L1718">                    + e.getMessage(), e);</span>
<span class="nc" id="L1719">        }</span>
<span class="nc" id="L1720">    }</span>
    
    protected boolean calendarExists(Connection conn, String calName)
        throws JobPersistenceException {
        try {
<span class="nc" id="L1725">            return getDelegate().calendarExists(conn, calName);</span>
<span class="nc" id="L1726">        } catch (SQLException e) {</span>
<span class="nc" id="L1727">            throw new JobPersistenceException(</span>
                    &quot;Couldn't determine calendar existence (&quot; + calName + &quot;): &quot;
<span class="nc" id="L1729">                            + e.getMessage(), e);</span>
        }
    }

    /**
     * &lt;p&gt;
     * Remove (delete) the &lt;code&gt;{@link org.quartz.Calendar}&lt;/code&gt; with the
     * given name.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If removal of the &lt;code&gt;Calendar&lt;/code&gt; would result in
     * &lt;code&gt;Trigger&lt;/code&gt;s pointing to non-existent calendars, then a
     * &lt;code&gt;JobPersistenceException&lt;/code&gt; will be thrown.&lt;/p&gt;
     *       *
     * @param calName The name of the &lt;code&gt;Calendar&lt;/code&gt; to be removed.
     * @return &lt;code&gt;true&lt;/code&gt; if a &lt;code&gt;Calendar&lt;/code&gt; with the given name
     * was found and removed from the store.
     */
    public boolean removeCalendar(final String calName)
        throws JobPersistenceException {
<span class="nc" id="L1750">        return (Boolean) executeInLock(</span>
                LOCK_TRIGGER_ACCESS,
<span class="nc" id="L1752">                new TransactionCallback() {</span>
                    public Object execute(Connection conn) throws JobPersistenceException {
<span class="nc bnc" id="L1754" title="All 2 branches missed.">                        return removeCalendar(conn, calName) ?</span>
                                Boolean.TRUE : Boolean.FALSE;
                    }
                });
    }
    
    protected boolean removeCalendar(Connection conn, 
            String calName) throws JobPersistenceException {
        try {
<span class="nc bnc" id="L1763" title="All 2 branches missed.">            if (getDelegate().calendarIsReferenced(conn, calName)) { </span>
<span class="nc" id="L1764">                throw new JobPersistenceException(</span>
                    &quot;Calender cannot be removed if it referenced by a trigger!&quot;); 
            }

<span class="nc bnc" id="L1768" title="All 2 branches missed.">            if (!isClustered) {</span>
<span class="nc" id="L1769">                calendarCache.remove(calName);</span>
            }

<span class="nc bnc" id="L1772" title="All 2 branches missed.">            return (getDelegate().deleteCalendar(conn, calName) &gt; 0);</span>
<span class="nc" id="L1773">        } catch (SQLException e) {</span>
<span class="nc" id="L1774">            throw new JobPersistenceException(&quot;Couldn't remove calendar: &quot;</span>
<span class="nc" id="L1775">                    + e.getMessage(), e);</span>
        }
    }

    /**
     * &lt;p&gt;
     * Retrieve the given &lt;code&gt;{@link org.quartz.Trigger}&lt;/code&gt;.
     * &lt;/p&gt;
     * 
     * @param calName
     *          The name of the &lt;code&gt;Calendar&lt;/code&gt; to be retrieved.
     * @return The desired &lt;code&gt;Calendar&lt;/code&gt;, or null if there is no
     *         match.
     */
    public Calendar retrieveCalendar(final String calName)
        throws JobPersistenceException {
<span class="nc" id="L1791">        return (Calendar)executeWithoutLock( // no locks necessary for read...</span>
<span class="nc" id="L1792">            new TransactionCallback() {</span>
                public Object execute(Connection conn) throws JobPersistenceException {
<span class="nc" id="L1794">                    return retrieveCalendar(conn, calName);</span>
                }
            });
    }
    
    protected Calendar retrieveCalendar(Connection conn,
            String calName)
        throws JobPersistenceException {
        // all calendars are persistent, but we can lazy-cache them during run
        // time as long as we aren't running clustered.
<span class="nc bnc" id="L1804" title="All 2 branches missed.">        Calendar cal = (isClustered) ? null : calendarCache.get(calName);</span>
<span class="nc bnc" id="L1805" title="All 2 branches missed.">        if (cal != null) {</span>
<span class="nc" id="L1806">            return cal;</span>
        }

        try {
<span class="nc" id="L1810">            cal = getDelegate().selectCalendar(conn, calName);</span>
<span class="nc bnc" id="L1811" title="All 2 branches missed.">            if (!isClustered) {</span>
<span class="nc" id="L1812">                calendarCache.put(calName, cal); // lazy-cache...</span>
            }
<span class="nc" id="L1814">            return cal;</span>
<span class="nc" id="L1815">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L1816">            throw new JobPersistenceException(</span>
                    &quot;Couldn't retrieve calendar because a required class was not found: &quot;
<span class="nc" id="L1818">                            + e.getMessage(), e);</span>
<span class="nc" id="L1819">        } catch (IOException e) {</span>
<span class="nc" id="L1820">            throw new JobPersistenceException(</span>
                    &quot;Couldn't retrieve calendar because the BLOB couldn't be deserialized: &quot;
<span class="nc" id="L1822">                            + e.getMessage(), e);</span>
<span class="nc" id="L1823">        } catch (SQLException e) {</span>
<span class="nc" id="L1824">            throw new JobPersistenceException(&quot;Couldn't retrieve calendar: &quot;</span>
<span class="nc" id="L1825">                    + e.getMessage(), e);</span>
        }
    }

    /**
     * &lt;p&gt;
     * Get the number of &lt;code&gt;{@link org.quartz.Job}&lt;/code&gt; s that are
     * stored in the &lt;code&gt;JobStore&lt;/code&gt;.
     * &lt;/p&gt;
     */
    public int getNumberOfJobs()
        throws JobPersistenceException {
<span class="nc" id="L1837">        return (Integer) executeWithoutLock( // no locks necessary for read...</span>
<span class="nc" id="L1838">                new TransactionCallback() {</span>
                    public Object execute(Connection conn) throws JobPersistenceException {
<span class="nc" id="L1840">                        return getNumberOfJobs(conn);</span>
                    }
                });
    }
    
    protected int getNumberOfJobs(Connection conn)
        throws JobPersistenceException {
        try {
<span class="nc" id="L1848">            return getDelegate().selectNumJobs(conn);</span>
<span class="nc" id="L1849">        } catch (SQLException e) {</span>
<span class="nc" id="L1850">            throw new JobPersistenceException(</span>
<span class="nc" id="L1851">                    &quot;Couldn't obtain number of jobs: &quot; + e.getMessage(), e);</span>
        }
    }

    /**
     * &lt;p&gt;
     * Get the number of &lt;code&gt;{@link org.quartz.Trigger}&lt;/code&gt; s that are
     * stored in the &lt;code&gt;JobsStore&lt;/code&gt;.
     * &lt;/p&gt;
     */
    public int getNumberOfTriggers()
        throws JobPersistenceException {
<span class="nc" id="L1863">        return (Integer) executeWithoutLock( // no locks necessary for read...</span>
<span class="nc" id="L1864">                new TransactionCallback() {</span>
                    public Object execute(Connection conn) throws JobPersistenceException {
<span class="nc" id="L1866">                        return getNumberOfTriggers(conn);</span>
                    }
                });
    }
    
    protected int getNumberOfTriggers(Connection conn)
        throws JobPersistenceException {
        try {
<span class="nc" id="L1874">            return getDelegate().selectNumTriggers(conn);</span>
<span class="nc" id="L1875">        } catch (SQLException e) {</span>
<span class="nc" id="L1876">            throw new JobPersistenceException(</span>
<span class="nc" id="L1877">                    &quot;Couldn't obtain number of triggers: &quot; + e.getMessage(), e);</span>
        }
    }

    /**
     * &lt;p&gt;
     * Get the number of &lt;code&gt;{@link org.quartz.Calendar}&lt;/code&gt; s that are
     * stored in the &lt;code&gt;JobsStore&lt;/code&gt;.
     * &lt;/p&gt;
     */
    public int getNumberOfCalendars()
        throws JobPersistenceException {
<span class="nc" id="L1889">        return (Integer) executeWithoutLock( // no locks necessary for read...</span>
<span class="nc" id="L1890">                new TransactionCallback() {</span>
                    public Object execute(Connection conn) throws JobPersistenceException {
<span class="nc" id="L1892">                        return getNumberOfCalendars(conn);</span>
                    }
                });
    }
    
    protected int getNumberOfCalendars(Connection conn)
        throws JobPersistenceException {
        try {
<span class="nc" id="L1900">            return getDelegate().selectNumCalendars(conn);</span>
<span class="nc" id="L1901">        } catch (SQLException e) {</span>
<span class="nc" id="L1902">            throw new JobPersistenceException(</span>
<span class="nc" id="L1903">                    &quot;Couldn't obtain number of calendars: &quot; + e.getMessage(), e);</span>
        }
    }

    /**
     * &lt;p&gt;
     * Get the names of all of the &lt;code&gt;{@link org.quartz.Job}&lt;/code&gt; s that
     * matcher the given groupMatcher.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If there are no jobs in the given group name, the result should be an empty Set
     * &lt;/p&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public Set&lt;JobKey&gt; getJobKeys(final GroupMatcher&lt;JobKey&gt; matcher)
        throws JobPersistenceException {
<span class="fc" id="L1920">        return (Set&lt;JobKey&gt;)executeWithoutLock( // no locks necessary for read...</span>
<span class="fc" id="L1921">            new TransactionCallback() {</span>
                public Object execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L1923">                    return getJobNames(conn, matcher);</span>
                }
            });
    }
    
    protected Set&lt;JobKey&gt; getJobNames(Connection conn,
            GroupMatcher&lt;JobKey&gt; matcher) throws JobPersistenceException {
        Set&lt;JobKey&gt; jobNames;

        try {
<span class="fc" id="L1933">            jobNames = getDelegate().selectJobsInGroup(conn, matcher);</span>
<span class="nc" id="L1934">        } catch (SQLException e) {</span>
<span class="nc" id="L1935">            throw new JobPersistenceException(&quot;Couldn't obtain job names: &quot;</span>
<span class="nc" id="L1936">                    + e.getMessage(), e);</span>
<span class="fc" id="L1937">        }</span>

<span class="fc" id="L1939">        return jobNames;</span>
    }
    
    
    /**
     * Determine whether a {@link Job} with the given identifier already 
     * exists within the scheduler.
     * 
     * @param jobKey the identifier to check for
     * @return true if a Job exists with the given identifier
     * @throws JobPersistenceException
     */
    public boolean checkExists(final JobKey jobKey) throws JobPersistenceException {
<span class="fc" id="L1952">        return (Boolean)executeWithoutLock( // no locks necessary for read...</span>
<span class="fc" id="L1953">                new TransactionCallback() {</span>
                    public Object execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L1955">                        return checkExists(conn, jobKey);</span>
                    }
                });
    }
   
    protected boolean checkExists(Connection conn, JobKey jobKey) throws JobPersistenceException {
        try {
<span class="fc" id="L1962">            return getDelegate().jobExists(conn, jobKey);</span>
<span class="nc" id="L1963">        } catch (SQLException e) {</span>
<span class="nc" id="L1964">            throw new JobPersistenceException(&quot;Couldn't check for existence of job: &quot;</span>
<span class="nc" id="L1965">                    + e.getMessage(), e);</span>
        }
    }
    
    /**
     * Determine whether a {@link Trigger} with the given identifier already 
     * exists within the scheduler.
     * 
     * @param triggerKey the identifier to check for
     * @return true if a Trigger exists with the given identifier
     * @throws JobPersistenceException
     */
    public boolean checkExists(final TriggerKey triggerKey) throws JobPersistenceException {
<span class="fc" id="L1978">        return (Boolean)executeWithoutLock( // no locks necessary for read...</span>
<span class="fc" id="L1979">                new TransactionCallback() {</span>
                    public Object execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L1981">                        return checkExists(conn, triggerKey);</span>
                    }
                });
    }
    
    protected boolean checkExists(Connection conn, TriggerKey triggerKey) throws JobPersistenceException {
        try {
<span class="fc" id="L1988">            return getDelegate().triggerExists(conn, triggerKey);</span>
<span class="nc" id="L1989">        } catch (SQLException e) {</span>
<span class="nc" id="L1990">            throw new JobPersistenceException(&quot;Couldn't check for existence of job: &quot;</span>
<span class="nc" id="L1991">                    + e.getMessage(), e);</span>
        }
    }

    /**
     * Clear (delete!) all scheduling data - all {@link Job}s, {@link Trigger}s
     * {@link Calendar}s.
     * 
     * @throws JobPersistenceException
     */
    public void clearAllSchedulingData() throws JobPersistenceException {
<span class="nc" id="L2002">        executeInLock(</span>
                LOCK_TRIGGER_ACCESS,
<span class="nc" id="L2004">                new VoidTransactionCallback() {</span>
                    public void executeVoid(Connection conn) throws JobPersistenceException {
<span class="nc" id="L2006">                        clearAllSchedulingData(conn);</span>
<span class="nc" id="L2007">                    }</span>
                });
<span class="nc" id="L2009">    }</span>
    
    protected void clearAllSchedulingData(Connection conn) throws JobPersistenceException {
        try {
<span class="nc" id="L2013">            getDelegate().clearData(conn);</span>
<span class="nc" id="L2014">        } catch (SQLException e) {</span>
<span class="nc" id="L2015">            throw new JobPersistenceException(&quot;Error clearing scheduling data: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L2016">        }</span>
<span class="nc" id="L2017">    }</span>
    
    /**
     * &lt;p&gt;
     * Get the names of all of the &lt;code&gt;{@link org.quartz.Trigger}&lt;/code&gt; s
     * that match the given group Matcher.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If there are no triggers in the given group name, the result should be a
     * an empty Set (not &lt;code&gt;null&lt;/code&gt;).
     * &lt;/p&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public Set&lt;TriggerKey&gt; getTriggerKeys(final GroupMatcher&lt;TriggerKey&gt; matcher)
        throws JobPersistenceException {
<span class="fc" id="L2033">        return (Set&lt;TriggerKey&gt;)executeWithoutLock( // no locks necessary for read...</span>
<span class="fc" id="L2034">            new TransactionCallback() {</span>
                public Object execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L2036">                    return getTriggerNames(conn, matcher);</span>
                }
            });
    }
    
    protected Set&lt;TriggerKey&gt; getTriggerNames(Connection conn,
            GroupMatcher&lt;TriggerKey&gt; matcher) throws JobPersistenceException {

        Set&lt;TriggerKey&gt; trigNames;

        try {
<span class="fc" id="L2047">            trigNames = getDelegate().selectTriggersInGroup(conn, matcher);</span>
<span class="nc" id="L2048">        } catch (SQLException e) {</span>
<span class="nc" id="L2049">            throw new JobPersistenceException(&quot;Couldn't obtain trigger names: &quot;</span>
<span class="nc" id="L2050">                    + e.getMessage(), e);</span>
<span class="fc" id="L2051">        }</span>

<span class="fc" id="L2053">        return trigNames;</span>
    }


    /**
     * &lt;p&gt;
     * Get the names of all of the &lt;code&gt;{@link org.quartz.Job}&lt;/code&gt;
     * groups.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If there are no known group names, the result should be a zero-length
     * array (not &lt;code&gt;null&lt;/code&gt;).
     * &lt;/p&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public List&lt;String&gt; getJobGroupNames()
        throws JobPersistenceException {
<span class="fc" id="L2071">        return (List&lt;String&gt;)executeWithoutLock( // no locks necessary for read...</span>
<span class="fc" id="L2072">            new TransactionCallback() {</span>
                public Object execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L2074">                    return getJobGroupNames(conn);</span>
                }
            });
    }
    
    protected List&lt;String&gt; getJobGroupNames(Connection conn)
        throws JobPersistenceException {

        List&lt;String&gt; groupNames;

        try {
<span class="fc" id="L2085">            groupNames = getDelegate().selectJobGroups(conn);</span>
<span class="nc" id="L2086">        } catch (SQLException e) {</span>
<span class="nc" id="L2087">            throw new JobPersistenceException(&quot;Couldn't obtain job groups: &quot;</span>
<span class="nc" id="L2088">                    + e.getMessage(), e);</span>
<span class="fc" id="L2089">        }</span>

<span class="fc" id="L2091">        return groupNames;</span>
    }

    /**
     * &lt;p&gt;
     * Get the names of all of the &lt;code&gt;{@link org.quartz.Trigger}&lt;/code&gt;
     * groups.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If there are no known group names, the result should be a zero-length
     * array (not &lt;code&gt;null&lt;/code&gt;).
     * &lt;/p&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public List&lt;String&gt; getTriggerGroupNames()
        throws JobPersistenceException {
<span class="fc" id="L2108">        return (List&lt;String&gt;)executeWithoutLock( // no locks necessary for read...</span>
<span class="fc" id="L2109">            new TransactionCallback() {</span>
                public Object execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L2111">                    return getTriggerGroupNames(conn);</span>
                }
            });        
    }
    
    protected List&lt;String&gt; getTriggerGroupNames(Connection conn) throws JobPersistenceException {

        List&lt;String&gt; groupNames;

        try {
<span class="fc" id="L2121">            groupNames = getDelegate().selectTriggerGroups(conn);</span>
<span class="nc" id="L2122">        } catch (SQLException e) {</span>
<span class="nc" id="L2123">            throw new JobPersistenceException(</span>
<span class="nc" id="L2124">                    &quot;Couldn't obtain trigger groups: &quot; + e.getMessage(), e);</span>
<span class="fc" id="L2125">        }</span>

<span class="fc" id="L2127">        return groupNames;</span>
    }

    /**
     * &lt;p&gt;
     * Get the names of all of the &lt;code&gt;{@link org.quartz.Calendar}&lt;/code&gt; s
     * in the &lt;code&gt;JobStore&lt;/code&gt;.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If there are no Calendars in the given group name, the result should be
     * a zero-length array (not &lt;code&gt;null&lt;/code&gt;).
     * &lt;/p&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public List&lt;String&gt; getCalendarNames()
        throws JobPersistenceException {
<span class="nc" id="L2144">        return (List&lt;String&gt;)executeWithoutLock( // no locks necessary for read...</span>
<span class="nc" id="L2145">            new TransactionCallback() {</span>
                public Object execute(Connection conn) throws JobPersistenceException {
<span class="nc" id="L2147">                    return getCalendarNames(conn);</span>
                }
            });      
    }
    
    protected List&lt;String&gt; getCalendarNames(Connection conn)
        throws JobPersistenceException {
        try {
<span class="nc" id="L2155">            return getDelegate().selectCalendars(conn);</span>
<span class="nc" id="L2156">        } catch (SQLException e) {</span>
<span class="nc" id="L2157">            throw new JobPersistenceException(</span>
<span class="nc" id="L2158">                    &quot;Couldn't obtain trigger groups: &quot; + e.getMessage(), e);</span>
        }
    }

    /**
     * &lt;p&gt;
     * Get all of the Triggers that are associated to the given Job.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If there are no matches, a zero-length array should be returned.
     * &lt;/p&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public List&lt;OperableTrigger&gt; getTriggersForJob(final JobKey jobKey) throws JobPersistenceException {
<span class="fc" id="L2173">        return (List&lt;OperableTrigger&gt;)executeWithoutLock( // no locks necessary for read...</span>
<span class="fc" id="L2174">            new TransactionCallback() {</span>
                public Object execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L2176">                    return getTriggersForJob(conn, jobKey);</span>
                }
            });
    }
    
    protected List&lt;OperableTrigger&gt; getTriggersForJob(Connection conn,
            JobKey key)
        throws JobPersistenceException {
        List&lt;OperableTrigger&gt; list;

        try {
<span class="fc" id="L2187">            list = getDelegate()</span>
<span class="fc" id="L2188">                    .selectTriggersForJob(conn, key);</span>
<span class="nc" id="L2189">        } catch (Exception e) {</span>
<span class="nc" id="L2190">            throw new JobPersistenceException(</span>
<span class="nc" id="L2191">                    &quot;Couldn't obtain triggers for job: &quot; + e.getMessage(), e);</span>
<span class="fc" id="L2192">        }</span>

<span class="fc" id="L2194">        return list;</span>
    }

    /**
     * &lt;p&gt;
     * Pause the &lt;code&gt;{@link org.quartz.Trigger}&lt;/code&gt; with the given name.
     * &lt;/p&gt;
     * 
     * @see #resumeTrigger(TriggerKey)
     */
    public void pauseTrigger(final TriggerKey triggerKey) throws JobPersistenceException {
<span class="fc" id="L2205">        executeInLock(</span>
            LOCK_TRIGGER_ACCESS,
<span class="fc" id="L2207">            new VoidTransactionCallback() {</span>
                public void executeVoid(Connection conn) throws JobPersistenceException {
<span class="fc" id="L2209">                    pauseTrigger(conn, triggerKey);</span>
<span class="fc" id="L2210">                }</span>
            });
<span class="fc" id="L2212">    }</span>
    
    /**
     * &lt;p&gt;
     * Pause the &lt;code&gt;{@link org.quartz.Trigger}&lt;/code&gt; with the given name.
     * &lt;/p&gt;
     * 
     * @see #resumeTrigger(Connection, TriggerKey)
     */
    public void pauseTrigger(Connection conn, 
            TriggerKey triggerKey)
        throws JobPersistenceException {

        try {
<span class="fc" id="L2226">            String oldState = getDelegate().selectTriggerState(conn,</span>
                    triggerKey);

<span class="fc bfc" id="L2229" title="All 2 branches covered.">            if (oldState.equals(STATE_WAITING)</span>
<span class="pc bpc" id="L2230" title="1 of 2 branches missed.">                    || oldState.equals(STATE_ACQUIRED)) {</span>

<span class="fc" id="L2232">                getDelegate().updateTriggerState(conn, triggerKey,</span>
                        STATE_PAUSED);
<span class="nc bnc" id="L2234" title="All 2 branches missed.">            } else if (oldState.equals(STATE_BLOCKED)) {</span>
<span class="nc" id="L2235">                getDelegate().updateTriggerState(conn, triggerKey,</span>
                        STATE_PAUSED_BLOCKED);
            }
<span class="nc" id="L2238">        } catch (SQLException e) {</span>
<span class="nc" id="L2239">            throw new JobPersistenceException(&quot;Couldn't pause trigger '&quot;</span>
<span class="nc" id="L2240">                    + triggerKey + &quot;': &quot; + e.getMessage(), e);</span>
<span class="fc" id="L2241">        }</span>
<span class="fc" id="L2242">    }</span>

    /**
     * &lt;p&gt;
     * Pause the &lt;code&gt;{@link org.quartz.Job}&lt;/code&gt; with the given name - by
     * pausing all of its current &lt;code&gt;Trigger&lt;/code&gt;s.
     * &lt;/p&gt;
     * 
     * @see #resumeJob(JobKey)
     */
    public void pauseJob(final JobKey jobKey) throws JobPersistenceException {
<span class="nc" id="L2253">        executeInLock(</span>
            LOCK_TRIGGER_ACCESS,
<span class="nc" id="L2255">            new VoidTransactionCallback() {</span>
                public void executeVoid(Connection conn) throws JobPersistenceException {
<span class="nc" id="L2257">                    List&lt;OperableTrigger&gt; triggers = getTriggersForJob(conn, jobKey);</span>
<span class="nc bnc" id="L2258" title="All 2 branches missed.">                    for (OperableTrigger trigger: triggers) {</span>
<span class="nc" id="L2259">                        pauseTrigger(conn, trigger.getKey());</span>
<span class="nc" id="L2260">                    }</span>
<span class="nc" id="L2261">                }</span>
            });
<span class="nc" id="L2263">    }</span>
    
    /**
     * &lt;p&gt;
     * Pause all of the &lt;code&gt;{@link org.quartz.Job}s&lt;/code&gt; matching the given
     * groupMatcher - by pausing all of their &lt;code&gt;Trigger&lt;/code&gt;s.
     * &lt;/p&gt;
     * 
     * @see #resumeJobs(org.quartz.impl.matchers.GroupMatcher)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public Set&lt;String&gt; pauseJobs(final GroupMatcher&lt;JobKey&gt; matcher)
        throws JobPersistenceException {
<span class="fc" id="L2276">        return (Set&lt;String&gt;) executeInLock(</span>
            LOCK_TRIGGER_ACCESS,
<span class="fc" id="L2278">            new TransactionCallback() {</span>
                public Set&lt;String&gt; execute(final Connection conn) throws JobPersistenceException {
<span class="fc" id="L2280">                    Set&lt;String&gt; groupNames = new HashSet&lt;String&gt;();</span>
<span class="fc" id="L2281">                    Set&lt;JobKey&gt; jobNames = getJobNames(conn, matcher);</span>

<span class="fc bfc" id="L2283" title="All 2 branches covered.">                    for (JobKey jobKey : jobNames) {</span>
<span class="fc" id="L2284">                        List&lt;OperableTrigger&gt; triggers = getTriggersForJob(conn, jobKey);</span>
<span class="fc bfc" id="L2285" title="All 2 branches covered.">                        for (OperableTrigger trigger : triggers) {</span>
<span class="fc" id="L2286">                            pauseTrigger(conn, trigger.getKey());</span>
<span class="fc" id="L2287">                        }</span>
<span class="fc" id="L2288">                        groupNames.add(jobKey.getGroup());</span>
<span class="fc" id="L2289">                    }</span>

<span class="fc" id="L2291">                    return groupNames;</span>
                }
            }
            );
    }
    
    /**
     * Determines if a Trigger for the given job should be blocked.  
     * State can only transition to STATE_PAUSED_BLOCKED/BLOCKED from 
     * PAUSED/STATE_WAITING respectively.
     * 
     * @return STATE_PAUSED_BLOCKED, BLOCKED, or the currentState. 
     */
    protected String checkBlockedState(
            Connection conn, JobKey jobKey, String currentState)
        throws JobPersistenceException {

        // State can only transition to BLOCKED from PAUSED or WAITING.
<span class="fc bfc" id="L2309" title="All 2 branches covered.">        if ((!currentState.equals(STATE_WAITING)) &amp;&amp;</span>
<span class="pc bpc" id="L2310" title="1 of 2 branches missed.">            (!currentState.equals(STATE_PAUSED))) {</span>
<span class="fc" id="L2311">            return currentState;</span>
        }
        
        try {
<span class="fc" id="L2315">            List&lt;FiredTriggerRecord&gt; lst = getDelegate().selectFiredTriggerRecordsByJob(conn,</span>
<span class="fc" id="L2316">                    jobKey.getName(), jobKey.getGroup());</span>

<span class="fc bfc" id="L2318" title="All 2 branches covered.">            if (lst.size() &gt; 0) {</span>
<span class="fc" id="L2319">                FiredTriggerRecord rec = lst.get(0);</span>
<span class="pc bpc" id="L2320" title="1 of 2 branches missed.">                if (rec.isJobDisallowsConcurrentExecution()) { // OLD_TODO: worry about failed/recovering/volatile job  states?</span>
<span class="nc bnc" id="L2321" title="All 2 branches missed.">                    return (STATE_PAUSED.equals(currentState)) ? STATE_PAUSED_BLOCKED : STATE_BLOCKED;</span>
                }
            }

<span class="fc" id="L2325">            return currentState;</span>
<span class="nc" id="L2326">        } catch (SQLException e) {</span>
<span class="nc" id="L2327">            throw new JobPersistenceException(</span>
                &quot;Couldn't determine if trigger should be in a blocked state '&quot;
                    + jobKey + &quot;': &quot;
<span class="nc" id="L2330">                    + e.getMessage(), e);</span>
        }

    }

    /**
     * &lt;p&gt;
     * Resume (un-pause) the &lt;code&gt;{@link org.quartz.Trigger}&lt;/code&gt; with the
     * given name.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If the &lt;code&gt;Trigger&lt;/code&gt; missed one or more fire-times, then the
     * &lt;code&gt;Trigger&lt;/code&gt;'s misfire instruction will be applied.
     * &lt;/p&gt;
     * 
     * @see #pauseTrigger(TriggerKey)
     */
    public void resumeTrigger(final TriggerKey triggerKey) throws JobPersistenceException {
<span class="fc" id="L2349">        executeInLock(</span>
            LOCK_TRIGGER_ACCESS,
<span class="fc" id="L2351">            new VoidTransactionCallback() {</span>
                public void executeVoid(Connection conn) throws JobPersistenceException {
<span class="fc" id="L2353">                    resumeTrigger(conn, triggerKey);</span>
<span class="fc" id="L2354">                }</span>
            });
<span class="fc" id="L2356">    }</span>
    
    /**
     * &lt;p&gt;
     * Resume (un-pause) the &lt;code&gt;{@link org.quartz.Trigger}&lt;/code&gt; with the
     * given name.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If the &lt;code&gt;Trigger&lt;/code&gt; missed one or more fire-times, then the
     * &lt;code&gt;Trigger&lt;/code&gt;'s misfire instruction will be applied.
     * &lt;/p&gt;
     * 
     * @see #pauseTrigger(Connection, TriggerKey)
     */
    public void resumeTrigger(Connection conn, 
            TriggerKey key)
        throws JobPersistenceException {
        try {

<span class="fc" id="L2376">            TriggerStatus status = getDelegate().selectTriggerStatus(conn,</span>
                    key);

<span class="pc bpc" id="L2379" title="2 of 4 branches missed.">            if (status == null || status.getNextFireTime() == null) {</span>
<span class="nc" id="L2380">                return;</span>
            }

<span class="fc" id="L2383">            boolean blocked = false;</span>
<span class="pc bpc" id="L2384" title="1 of 2 branches missed.">            if(STATE_PAUSED_BLOCKED.equals(status.getStatus())) {</span>
<span class="nc" id="L2385">                blocked = true;</span>
            }

<span class="fc" id="L2388">            String newState = checkBlockedState(conn, status.getJobKey(), STATE_WAITING);</span>

<span class="fc" id="L2390">            boolean misfired = false;</span>

<span class="fc bfc" id="L2392" title="All 4 branches covered.">            if (schedulerRunning &amp;&amp; status.getNextFireTime().before(new Date())) {</span>
<span class="fc" id="L2393">                misfired = updateMisfiredTrigger(conn, key,</span>
                    newState, true);
            }

<span class="pc bpc" id="L2397" title="1 of 2 branches missed.">            if(!misfired) {</span>
<span class="pc bpc" id="L2398" title="1 of 2 branches missed.">                if(blocked) {</span>
<span class="nc" id="L2399">                    getDelegate().updateTriggerStateFromOtherState(conn,</span>
                            key, newState, STATE_PAUSED_BLOCKED);
                } else {
<span class="fc" id="L2402">                    getDelegate().updateTriggerStateFromOtherState(conn,</span>
                            key, newState, STATE_PAUSED);
                }
            } 

<span class="nc" id="L2407">        } catch (SQLException e) {</span>
<span class="nc" id="L2408">            throw new JobPersistenceException(&quot;Couldn't resume trigger '&quot;</span>
<span class="nc" id="L2409">                    + key + &quot;': &quot; + e.getMessage(), e);</span>
<span class="fc" id="L2410">        }</span>
<span class="fc" id="L2411">    }</span>

    /**
     * &lt;p&gt;
     * Resume (un-pause) the &lt;code&gt;{@link org.quartz.Job}&lt;/code&gt; with the
     * given name.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If any of the &lt;code&gt;Job&lt;/code&gt;'s&lt;code&gt;Trigger&lt;/code&gt; s missed one
     * or more fire-times, then the &lt;code&gt;Trigger&lt;/code&gt;'s misfire
     * instruction will be applied.
     * &lt;/p&gt;
     * 
     * @see #pauseJob(JobKey)
     */
    public void resumeJob(final JobKey jobKey) throws JobPersistenceException {
<span class="nc" id="L2428">        executeInLock(</span>
            LOCK_TRIGGER_ACCESS,
<span class="nc" id="L2430">            new VoidTransactionCallback() {</span>
                public void executeVoid(Connection conn) throws JobPersistenceException {
<span class="nc" id="L2432">                    List&lt;OperableTrigger&gt; triggers = getTriggersForJob(conn, jobKey);</span>
<span class="nc bnc" id="L2433" title="All 2 branches missed.">                    for (OperableTrigger trigger: triggers) {</span>
<span class="nc" id="L2434">                        resumeTrigger(conn, trigger.getKey());</span>
<span class="nc" id="L2435">                    }</span>
<span class="nc" id="L2436">                }</span>
            });
<span class="nc" id="L2438">    }</span>
    
    /**
     * &lt;p&gt;
     * Resume (un-pause) all of the &lt;code&gt;{@link org.quartz.Job}s&lt;/code&gt; in
     * the given group.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If any of the &lt;code&gt;Job&lt;/code&gt; s had &lt;code&gt;Trigger&lt;/code&gt; s that
     * missed one or more fire-times, then the &lt;code&gt;Trigger&lt;/code&gt;'s
     * misfire instruction will be applied.
     * &lt;/p&gt;
     * 
     * @see #pauseJobs(org.quartz.impl.matchers.GroupMatcher)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public Set&lt;String&gt; resumeJobs(final GroupMatcher&lt;JobKey&gt; matcher)
        throws JobPersistenceException {
<span class="fc" id="L2457">        return (Set&lt;String&gt;) executeInLock(</span>
            LOCK_TRIGGER_ACCESS,
<span class="fc" id="L2459">            new TransactionCallback() {</span>
                public Set&lt;String&gt; execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L2461">                    Set&lt;JobKey&gt; jobKeys = getJobNames(conn, matcher);</span>
<span class="fc" id="L2462">                    Set&lt;String&gt; groupNames = new HashSet&lt;String&gt;();</span>

<span class="fc bfc" id="L2464" title="All 2 branches covered.">                    for (JobKey jobKey: jobKeys) {</span>
<span class="fc" id="L2465">                        List&lt;OperableTrigger&gt; triggers = getTriggersForJob(conn, jobKey);</span>
<span class="fc bfc" id="L2466" title="All 2 branches covered.">                        for (OperableTrigger trigger: triggers) {</span>
<span class="fc" id="L2467">                            resumeTrigger(conn, trigger.getKey());</span>
<span class="fc" id="L2468">                        }</span>
<span class="fc" id="L2469">                        groupNames.add(jobKey.getGroup());</span>
<span class="fc" id="L2470">                    }</span>
<span class="fc" id="L2471">                    return groupNames;</span>
                }
            });
    }
    
    /**
     * &lt;p&gt;
     * Pause all of the &lt;code&gt;{@link org.quartz.Trigger}s&lt;/code&gt; matching the
     * given groupMatcher.
     * &lt;/p&gt;
     * 
     * @see #resumeTriggerGroup(java.sql.Connection, org.quartz.impl.matchers.GroupMatcher)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public Set&lt;String&gt; pauseTriggers(final GroupMatcher&lt;TriggerKey&gt; matcher)
        throws JobPersistenceException {
<span class="fc" id="L2487">        return (Set&lt;String&gt;) executeInLock(</span>
            LOCK_TRIGGER_ACCESS,
<span class="fc" id="L2489">            new TransactionCallback() {</span>
                public Set&lt;String&gt; execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L2491">                    return pauseTriggerGroup(conn, matcher);</span>
                }
            });
    }
    
    /**
     * &lt;p&gt;
     * Pause all of the &lt;code&gt;{@link org.quartz.Trigger}s&lt;/code&gt; matching the
     * given groupMatcher.
     * &lt;/p&gt;
     * 
     * @see #resumeTriggerGroup(java.sql.Connection, org.quartz.impl.matchers.GroupMatcher)
     */
    public Set&lt;String&gt; pauseTriggerGroup(Connection conn,
            GroupMatcher&lt;TriggerKey&gt; matcher) throws JobPersistenceException {

        try {

<span class="fc" id="L2509">            getDelegate().updateTriggerGroupStateFromOtherStates(</span>
                    conn, matcher, STATE_PAUSED, STATE_ACQUIRED,
                    STATE_WAITING, STATE_WAITING);

<span class="fc" id="L2513">            getDelegate().updateTriggerGroupStateFromOtherState(</span>
                    conn, matcher, STATE_PAUSED_BLOCKED, STATE_BLOCKED);

<span class="fc" id="L2516">            List&lt;String&gt; groups = getDelegate().selectTriggerGroups(conn, matcher);</span>
            
            // make sure to account for an exact group match for a group that doesn't yet exist
<span class="fc" id="L2519">            StringMatcher.StringOperatorName operator = matcher.getCompareWithOperator();</span>
<span class="pc bpc" id="L2520" title="1 of 4 branches missed.">            if (operator.equals(StringOperatorName.EQUALS) &amp;&amp; !groups.contains(matcher.getCompareToValue())) {</span>
<span class="fc" id="L2521">              groups.add(matcher.getCompareToValue());</span>
            }

<span class="fc bfc" id="L2524" title="All 2 branches covered.">            for (String group : groups) {</span>
<span class="pc bpc" id="L2525" title="1 of 2 branches missed.">                if (!getDelegate().isTriggerGroupPaused(conn, group)) {</span>
<span class="fc" id="L2526">                    getDelegate().insertPausedTriggerGroup(conn, group);</span>
                }
<span class="fc" id="L2528">            }</span>

<span class="fc" id="L2530">            return new HashSet&lt;String&gt;(groups);</span>

<span class="nc" id="L2532">        } catch (SQLException e) {</span>
<span class="nc" id="L2533">            throw new JobPersistenceException(&quot;Couldn't pause trigger group '&quot;</span>
<span class="nc" id="L2534">                    + matcher + &quot;': &quot; + e.getMessage(), e);</span>
        }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public Set&lt;String&gt; getPausedTriggerGroups() 
        throws JobPersistenceException {
<span class="fc" id="L2541">        return (Set&lt;String&gt;)executeWithoutLock( // no locks necessary for read...</span>
<span class="fc" id="L2542">            new TransactionCallback() {</span>
                public Object execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L2544">                    return getPausedTriggerGroups(conn);</span>
                }
            });
    }    
    
    /**
     * &lt;p&gt;
     * Pause all of the &lt;code&gt;{@link org.quartz.Trigger}s&lt;/code&gt; in the
     * given group.
     * &lt;/p&gt;
     * 
     * @see #resumeTriggers(org.quartz.impl.matchers.GroupMatcher)
     */
    public Set&lt;String&gt; getPausedTriggerGroups(Connection conn) 
        throws JobPersistenceException {

        try {
<span class="fc" id="L2561">            return getDelegate().selectPausedTriggerGroups(conn);</span>
<span class="nc" id="L2562">        } catch (SQLException e) {</span>
<span class="nc" id="L2563">            throw new JobPersistenceException(</span>
<span class="nc" id="L2564">                    &quot;Couldn't determine paused trigger groups: &quot; + e.getMessage(), e);</span>
        }
    }
    
    /**
     * &lt;p&gt;
     * Resume (un-pause) all of the &lt;code&gt;{@link org.quartz.Trigger}s&lt;/code&gt;
     * matching the given groupMatcher.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If any &lt;code&gt;Trigger&lt;/code&gt; missed one or more fire-times, then the
     * &lt;code&gt;Trigger&lt;/code&gt;'s misfire instruction will be applied.
     * &lt;/p&gt;
     * 
     * @see #pauseTriggers(org.quartz.impl.matchers.GroupMatcher)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public Set&lt;String&gt; resumeTriggers(final GroupMatcher&lt;TriggerKey&gt; matcher)
        throws JobPersistenceException {
<span class="fc" id="L2584">        return (Set&lt;String&gt;) executeInLock(</span>
            LOCK_TRIGGER_ACCESS,
<span class="fc" id="L2586">            new TransactionCallback() {</span>
                public Set&lt;String&gt; execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L2588">                    return resumeTriggerGroup(conn, matcher);</span>
                }
            });

    }
    
    /**
     * &lt;p&gt;
     * Resume (un-pause) all of the &lt;code&gt;{@link org.quartz.Trigger}s&lt;/code&gt;
     * matching the given groupMatcher.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If any &lt;code&gt;Trigger&lt;/code&gt; missed one or more fire-times, then the
     * &lt;code&gt;Trigger&lt;/code&gt;'s misfire instruction will be applied.
     * &lt;/p&gt;
     * 
     * @see #pauseTriggers(org.quartz.impl.matchers.GroupMatcher)
     */
    public Set&lt;String&gt; resumeTriggerGroup(Connection conn,
            GroupMatcher&lt;TriggerKey&gt; matcher) throws JobPersistenceException {

        try {

<span class="fc" id="L2612">            getDelegate().deletePausedTriggerGroup(conn, matcher);</span>
<span class="fc" id="L2613">            HashSet&lt;String&gt; groups = new HashSet&lt;String&gt;();</span>

<span class="fc" id="L2615">            Set&lt;TriggerKey&gt; keys = getDelegate().selectTriggersInGroup(conn,</span>
                    matcher);

<span class="fc bfc" id="L2618" title="All 2 branches covered.">            for (TriggerKey key: keys) {</span>
<span class="fc" id="L2619">                resumeTrigger(conn, key);</span>
<span class="fc" id="L2620">                groups.add(key.getGroup());</span>
<span class="fc" id="L2621">            }</span>

<span class="fc" id="L2623">            return groups;</span>

            // FUTURE_TODO: find an efficient way to resume triggers (better than the
            // above)... logic below is broken because of
            // findTriggersToBeBlocked()
            /*
             * int res =
             * getDelegate().updateTriggerGroupStateFromOtherState(conn,
             * groupName, STATE_WAITING, PAUSED);
             * 
             * if(res &gt; 0) {
             * 
             * long misfireTime = System.currentTimeMillis();
             * if(getMisfireThreshold() &gt; 0) misfireTime -=
             * getMisfireThreshold();
             * 
             * Key[] misfires =
             * getDelegate().selectMisfiredTriggersInGroupInState(conn,
             * groupName, STATE_WAITING, misfireTime);
             * 
             * List blockedTriggers = findTriggersToBeBlocked(conn,
             * groupName);
             * 
             * Iterator itr = blockedTriggers.iterator(); while(itr.hasNext()) {
             * Key key = (Key)itr.next();
             * getDelegate().updateTriggerState(conn, key.getName(),
             * key.getGroup(), BLOCKED); }
             * 
             * for(int i=0; i &lt; misfires.length; i++) {               String
             * newState = STATE_WAITING;
             * if(blockedTriggers.contains(misfires[i])) newState =
             * BLOCKED; updateMisfiredTrigger(conn,
             * misfires[i].getName(), misfires[i].getGroup(), newState, true); } }
             */

<span class="nc" id="L2658">        } catch (SQLException e) {</span>
<span class="nc" id="L2659">            throw new JobPersistenceException(&quot;Couldn't pause trigger group '&quot;</span>
<span class="nc" id="L2660">                    + matcher + &quot;': &quot; + e.getMessage(), e);</span>
        }
    }

    /**
     * &lt;p&gt;
     * Pause all triggers - equivalent of calling &lt;code&gt;pauseTriggerGroup(group)&lt;/code&gt;
     * on every group.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * When &lt;code&gt;resumeAll()&lt;/code&gt; is called (to un-pause), trigger misfire
     * instructions WILL be applied.
     * &lt;/p&gt;
     * 
     * @see #resumeAll()
     * @see #pauseTriggerGroup(java.sql.Connection, org.quartz.impl.matchers.GroupMatcher)
     */
    public void pauseAll() throws JobPersistenceException {
<span class="nc" id="L2679">        executeInLock(</span>
            LOCK_TRIGGER_ACCESS,
<span class="nc" id="L2681">            new VoidTransactionCallback() {</span>
                public void executeVoid(Connection conn) throws JobPersistenceException {
<span class="nc" id="L2683">                    pauseAll(conn);</span>
<span class="nc" id="L2684">                }</span>
            });
<span class="nc" id="L2686">    }</span>
    
    /**
     * &lt;p&gt;
     * Pause all triggers - equivalent of calling &lt;code&gt;pauseTriggerGroup(group)&lt;/code&gt;
     * on every group.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * When &lt;code&gt;resumeAll()&lt;/code&gt; is called (to un-pause), trigger misfire
     * instructions WILL be applied.
     * &lt;/p&gt;
     * 
     * @see #resumeAll(Connection)
     * @see #pauseTriggerGroup(java.sql.Connection, org.quartz.impl.matchers.GroupMatcher)
     */
    public void pauseAll(Connection conn)
        throws JobPersistenceException {

<span class="nc" id="L2705">        List&lt;String&gt; names = getTriggerGroupNames(conn);</span>

<span class="nc bnc" id="L2707" title="All 2 branches missed.">        for (String name: names) {</span>
<span class="nc" id="L2708">            pauseTriggerGroup(conn, GroupMatcher.triggerGroupEquals(name));</span>
<span class="nc" id="L2709">        }</span>

        try {
<span class="nc bnc" id="L2712" title="All 2 branches missed.">            if (!getDelegate().isTriggerGroupPaused(conn, ALL_GROUPS_PAUSED)) {</span>
<span class="nc" id="L2713">                getDelegate().insertPausedTriggerGroup(conn, ALL_GROUPS_PAUSED);</span>
            }

<span class="nc" id="L2716">        } catch (SQLException e) {</span>
<span class="nc" id="L2717">            throw new JobPersistenceException(</span>
<span class="nc" id="L2718">                    &quot;Couldn't pause all trigger groups: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L2719">        }</span>

<span class="nc" id="L2721">    }</span>

    /**
     * &lt;p&gt;
     * Resume (un-pause) all triggers - equivalent of calling &lt;code&gt;resumeTriggerGroup(group)&lt;/code&gt;
     * on every group.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If any &lt;code&gt;Trigger&lt;/code&gt; missed one or more fire-times, then the
     * &lt;code&gt;Trigger&lt;/code&gt;'s misfire instruction will be applied.
     * &lt;/p&gt;
     * 
     * @see #pauseAll()
     */
    public void resumeAll()
        throws JobPersistenceException {
<span class="nc" id="L2738">        executeInLock(</span>
            LOCK_TRIGGER_ACCESS,
<span class="nc" id="L2740">            new VoidTransactionCallback() {</span>
                public void executeVoid(Connection conn) throws JobPersistenceException {
<span class="nc" id="L2742">                    resumeAll(conn);</span>
<span class="nc" id="L2743">                }</span>
            });
<span class="nc" id="L2745">    }</span>
    
    /**
     * protected
     * &lt;p&gt;
     * Resume (un-pause) all triggers - equivalent of calling &lt;code&gt;resumeTriggerGroup(group)&lt;/code&gt;
     * on every group.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * If any &lt;code&gt;Trigger&lt;/code&gt; missed one or more fire-times, then the
     * &lt;code&gt;Trigger&lt;/code&gt;'s misfire instruction will be applied.
     * &lt;/p&gt;
     * 
     * @see #pauseAll(Connection)
     */
    public void resumeAll(Connection conn)
        throws JobPersistenceException {

<span class="nc" id="L2764">        List&lt;String&gt; names = getTriggerGroupNames(conn);</span>

<span class="nc bnc" id="L2766" title="All 2 branches missed.">        for (String name: names) {</span>
<span class="nc" id="L2767">            resumeTriggerGroup(conn, GroupMatcher.triggerGroupEquals(name));</span>
<span class="nc" id="L2768">        }</span>

        try {
<span class="nc" id="L2771">            getDelegate().deletePausedTriggerGroup(conn, ALL_GROUPS_PAUSED);</span>
<span class="nc" id="L2772">        } catch (SQLException e) {</span>
<span class="nc" id="L2773">            throw new JobPersistenceException(</span>
<span class="nc" id="L2774">                    &quot;Couldn't resume all trigger groups: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L2775">        }</span>
<span class="nc" id="L2776">    }</span>

<span class="fc" id="L2778">    private static long ftrCtr = System.currentTimeMillis();</span>

    protected synchronized String getFiredTriggerRecordId() {
<span class="fc" id="L2781">        return getInstanceId() + ftrCtr++;</span>
    }

    /**
     * &lt;p&gt;
     * Get a handle to the next N triggers to be fired, and mark them as 'reserved'
     * by the calling scheduler.
     * &lt;/p&gt;
     * 
     * @see #releaseAcquiredTrigger(OperableTrigger)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public List&lt;OperableTrigger&gt; acquireNextTriggers(final long noLaterThan, final int maxCount, final long timeWindow)
        throws JobPersistenceException {
        
        String lockName;
<span class="fc bfc" id="L2797" title="All 4 branches covered.">        if(isAcquireTriggersWithinLock() || maxCount &gt; 1) { </span>
<span class="fc" id="L2798">            lockName = LOCK_TRIGGER_ACCESS;</span>
        } else {
<span class="fc" id="L2800">            lockName = null;</span>
        }
<span class="fc" id="L2802">        return executeInNonManagedTXLock(lockName, </span>
<span class="fc" id="L2803">                new TransactionCallback&lt;List&lt;OperableTrigger&gt;&gt;() {</span>
                    public List&lt;OperableTrigger&gt; execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L2805">                        return acquireNextTrigger(conn, noLaterThan, maxCount, timeWindow);</span>
                    }
                },
<span class="fc" id="L2808">                new TransactionValidator&lt;List&lt;OperableTrigger&gt;&gt;() {</span>
                    public Boolean validate(Connection conn, List&lt;OperableTrigger&gt; result) throws JobPersistenceException {
                        try {
<span class="fc" id="L2811">                            List&lt;FiredTriggerRecord&gt; acquired = getDelegate().selectInstancesFiredTriggerRecords(conn, getInstanceId());</span>
<span class="fc" id="L2812">                            Set&lt;String&gt; fireInstanceIds = new HashSet&lt;String&gt;();</span>
<span class="fc bfc" id="L2813" title="All 2 branches covered.">                            for (FiredTriggerRecord ft : acquired) {</span>
<span class="fc" id="L2814">                                fireInstanceIds.add(ft.getFireInstanceId());</span>
<span class="fc" id="L2815">                            }</span>
<span class="fc bfc" id="L2816" title="All 2 branches covered.">                            for (OperableTrigger tr : result) {</span>
<span class="fc bfc" id="L2817" title="All 2 branches covered.">                                if (fireInstanceIds.contains(tr.getFireInstanceId())) {</span>
<span class="fc" id="L2818">                                    return true;</span>
                                }
<span class="fc" id="L2820">                            }</span>
<span class="fc" id="L2821">                            return false;</span>
<span class="nc" id="L2822">                        } catch (SQLException e) {</span>
<span class="nc" id="L2823">                            throw new JobPersistenceException(&quot;error validating trigger acquisition&quot;, e);</span>
                        }
                    }
                });
    }
    
    // FUTURE_TODO: this really ought to return something like a FiredTriggerBundle,
    // so that the fireInstanceId doesn't have to be on the trigger...
    protected List&lt;OperableTrigger&gt; acquireNextTrigger(Connection conn, long noLaterThan, int maxCount, long timeWindow)
        throws JobPersistenceException {
<span class="pc bpc" id="L2833" title="1 of 2 branches missed.">        if (timeWindow &lt; 0) {</span>
<span class="nc" id="L2834">          throw new IllegalArgumentException();</span>
        }
        
<span class="fc" id="L2837">        List&lt;OperableTrigger&gt; acquiredTriggers = new ArrayList&lt;OperableTrigger&gt;();</span>
<span class="fc" id="L2838">        Set&lt;JobKey&gt; acquiredJobKeysForNoConcurrentExec = new HashSet&lt;JobKey&gt;();</span>
<span class="fc" id="L2839">        final int MAX_DO_LOOP_RETRY = 3;</span>
<span class="fc" id="L2840">        int currentLoopCount = 0;</span>
        do {
<span class="fc" id="L2842">            currentLoopCount ++;</span>
            try {
<span class="fc" id="L2844">                List&lt;TriggerKey&gt; keys = getDelegate().selectTriggerToAcquire(conn, noLaterThan + timeWindow, getMisfireTime(), maxCount);</span>
                
                // No trigger is ready to fire yet.
<span class="pc bpc" id="L2847" title="1 of 4 branches missed.">                if (keys == null || keys.size() == 0)</span>
<span class="fc" id="L2848">                    return acquiredTriggers;</span>

<span class="fc" id="L2850">                long batchEnd = noLaterThan;</span>

<span class="fc bfc" id="L2852" title="All 2 branches covered.">                for(TriggerKey triggerKey: keys) {</span>
                    // If our trigger is no longer available, try a new one.
<span class="fc" id="L2854">                    OperableTrigger nextTrigger = retrieveTrigger(conn, triggerKey);</span>
<span class="pc bpc" id="L2855" title="1 of 2 branches missed.">                    if(nextTrigger == null) {</span>
<span class="nc" id="L2856">                        continue; // next trigger</span>
                    }
                    
                    // If trigger's job is set as @DisallowConcurrentExecution, and it has already been added to result, then
                    // put it back into the timeTriggers set and continue to search for next trigger.
<span class="fc" id="L2861">                    JobKey jobKey = nextTrigger.getJobKey();</span>
                    JobDetail job;
                    try {
<span class="fc" id="L2864">                        job = retrieveJob(conn, jobKey);</span>
<span class="fc" id="L2865">                    } catch (JobPersistenceException jpe) {</span>
                        try {
<span class="fc" id="L2867">                            getLog().error(&quot;Error retrieving job, setting trigger state to ERROR.&quot;, jpe);</span>
<span class="fc" id="L2868">                            getDelegate().updateTriggerState(conn, triggerKey, STATE_ERROR);</span>
<span class="nc" id="L2869">                        } catch (SQLException sqle) {</span>
<span class="nc" id="L2870">                            getLog().error(&quot;Unable to set trigger state to ERROR.&quot;, sqle);</span>
<span class="fc" id="L2871">                        }</span>
<span class="fc" id="L2872">                        continue;</span>
<span class="fc" id="L2873">                    }</span>
                    
<span class="fc bfc" id="L2875" title="All 2 branches covered.">                    if (job.isConcurrentExectionDisallowed()) {</span>
<span class="pc bpc" id="L2876" title="1 of 2 branches missed.">                        if (acquiredJobKeysForNoConcurrentExec.contains(jobKey)) {</span>
<span class="nc" id="L2877">                            continue; // next trigger</span>
                        } else {
<span class="fc" id="L2879">                            acquiredJobKeysForNoConcurrentExec.add(jobKey);</span>
                        }
                    }

<span class="fc" id="L2883">                    Date nextFireTime = nextTrigger.getNextFireTime();</span>

                    // A trigger should not return NULL on nextFireTime when fetched from DB.
                    // But for whatever reason if we do have this (BAD trigger implementation or
                    // data?), we then should log a warning and continue to next trigger.
                    // User would need to manually fix these triggers from DB as they will not
                    // able to be clean up by Quartz since we are not returning it to be processed.
<span class="pc bpc" id="L2890" title="1 of 2 branches missed.">                    if (nextFireTime == null) {</span>
<span class="nc" id="L2891">                        log.warn(&quot;Trigger {} returned null on nextFireTime and yet still exists in DB!&quot;,</span>
<span class="nc" id="L2892">                            nextTrigger.getKey());</span>
<span class="nc" id="L2893">                        continue;</span>
                    }
                    
<span class="fc bfc" id="L2896" title="All 2 branches covered.">                    if (nextFireTime.getTime() &gt; batchEnd) {</span>
<span class="fc" id="L2897">                      break;</span>
                    }
                    // We now have a acquired trigger, let's add to return list.
                    // If our trigger was no longer in the expected state, try a new one.
<span class="fc" id="L2901">                    int rowsUpdated = getDelegate().updateTriggerStateFromOtherState(conn, triggerKey, STATE_ACQUIRED, STATE_WAITING);</span>
<span class="fc bfc" id="L2902" title="All 2 branches covered.">                    if (rowsUpdated &lt;= 0) {</span>
<span class="fc" id="L2903">                        continue; // next trigger</span>
                    }
<span class="fc" id="L2905">                    nextTrigger.setFireInstanceId(getFiredTriggerRecordId());</span>
<span class="fc" id="L2906">                    getDelegate().insertFiredTrigger(conn, nextTrigger, STATE_ACQUIRED, null);</span>

<span class="fc bfc" id="L2908" title="All 2 branches covered.">                    if(acquiredTriggers.isEmpty()) {</span>
<span class="fc" id="L2909">                        batchEnd = Math.max(nextFireTime.getTime(), System.currentTimeMillis()) + timeWindow;</span>
                    }
<span class="fc" id="L2911">                    acquiredTriggers.add(nextTrigger);</span>
<span class="fc" id="L2912">                }</span>

                // if we didn't end up with any trigger to fire from that first
                // batch, try again for another batch. We allow with a max retry count.
<span class="pc bpc" id="L2916" title="1 of 4 branches missed.">                if(acquiredTriggers.size() == 0 &amp;&amp; currentLoopCount &lt; MAX_DO_LOOP_RETRY) {</span>
<span class="fc" id="L2917">                    continue;</span>
                }
                
                // We are done with the while loop.
<span class="fc" id="L2921">                break;</span>
<span class="nc" id="L2922">            } catch (Exception e) {</span>
<span class="nc" id="L2923">                throw new JobPersistenceException(</span>
<span class="nc" id="L2924">                          &quot;Couldn't acquire next trigger: &quot; + e.getMessage(), e);</span>
            }
        } while (true);
        
        // Return the acquired trigger list
<span class="fc" id="L2929">        return acquiredTriggers;</span>
    }
    
    /**
     * &lt;p&gt;
     * Inform the &lt;code&gt;JobStore&lt;/code&gt; that the scheduler no longer plans to
     * fire the given &lt;code&gt;Trigger&lt;/code&gt;, that it had previously acquired
     * (reserved).
     * &lt;/p&gt;
     */
    public void releaseAcquiredTrigger(final OperableTrigger trigger) {
<span class="fc" id="L2940">        retryExecuteInNonManagedTXLock(</span>
            LOCK_TRIGGER_ACCESS,
<span class="fc" id="L2942">            new VoidTransactionCallback() {</span>
                public void executeVoid(Connection conn) throws JobPersistenceException {
<span class="fc" id="L2944">                    releaseAcquiredTrigger(conn, trigger);</span>
<span class="fc" id="L2945">                }</span>
            });
<span class="fc" id="L2947">    }</span>
    
    protected void releaseAcquiredTrigger(Connection conn,
            OperableTrigger trigger)
        throws JobPersistenceException {
        try {
<span class="fc" id="L2953">            getDelegate().updateTriggerStateFromOtherState(conn,</span>
<span class="fc" id="L2954">                    trigger.getKey(), STATE_WAITING, STATE_ACQUIRED);</span>
<span class="fc" id="L2955">            getDelegate().updateTriggerStateFromOtherState(conn,</span>
<span class="fc" id="L2956">                    trigger.getKey(), STATE_WAITING, STATE_BLOCKED);</span>
<span class="fc" id="L2957">            getDelegate().deleteFiredTrigger(conn, trigger.getFireInstanceId());</span>
<span class="nc" id="L2958">        } catch (SQLException e) {</span>
<span class="nc" id="L2959">            throw new JobPersistenceException(</span>
<span class="nc" id="L2960">                    &quot;Couldn't release acquired trigger: &quot; + e.getMessage(), e);</span>
<span class="fc" id="L2961">        }</span>
<span class="fc" id="L2962">    }</span>

    /**
     * &lt;p&gt;
     * Inform the &lt;code&gt;JobStore&lt;/code&gt; that the scheduler is now firing the
     * given &lt;code&gt;Trigger&lt;/code&gt; (executing its associated &lt;code&gt;Job&lt;/code&gt;),
     * that it had previously acquired (reserved).
     * &lt;/p&gt;
     * 
     * @return null if the trigger or its job or calendar no longer exist, or
     *         if the trigger was not successfully put into the 'executing'
     *         state.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public List&lt;TriggerFiredResult&gt; triggersFired(final List&lt;OperableTrigger&gt; triggers) throws JobPersistenceException {
<span class="fc" id="L2977">        return executeInNonManagedTXLock(LOCK_TRIGGER_ACCESS,</span>
<span class="fc" id="L2978">                new TransactionCallback&lt;List&lt;TriggerFiredResult&gt;&gt;() {</span>
                    public List&lt;TriggerFiredResult&gt; execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L2980">                        List&lt;TriggerFiredResult&gt; results = new ArrayList&lt;TriggerFiredResult&gt;();</span>

                        TriggerFiredResult result;
<span class="fc bfc" id="L2983" title="All 2 branches covered.">                        for (OperableTrigger trigger : triggers) {</span>
                            try {
<span class="fc" id="L2985">                              TriggerFiredBundle bundle = triggerFired(conn, trigger);</span>
<span class="fc" id="L2986">                              result = new TriggerFiredResult(bundle);</span>
<span class="fc" id="L2987">                            } catch (JobPersistenceException jpe) {</span>
<span class="fc" id="L2988">                                result = new TriggerFiredResult(jpe);</span>
<span class="nc" id="L2989">                            } catch(RuntimeException re) {</span>
<span class="nc" id="L2990">                                result = new TriggerFiredResult(re);</span>
<span class="fc" id="L2991">                            }</span>
<span class="fc" id="L2992">                            results.add(result);</span>
<span class="fc" id="L2993">                        }</span>

<span class="fc" id="L2995">                        return results;</span>
                    }
                },
<span class="fc" id="L2998">                new TransactionValidator&lt;List&lt;TriggerFiredResult&gt;&gt;() {</span>
                    @Override
                    public Boolean validate(Connection conn, List&lt;TriggerFiredResult&gt; result) throws JobPersistenceException {
                        try {
<span class="fc" id="L3002">                            List&lt;FiredTriggerRecord&gt; acquired = getDelegate().selectInstancesFiredTriggerRecords(conn, getInstanceId());</span>
<span class="fc" id="L3003">                            Set&lt;String&gt; executingTriggers = new HashSet&lt;String&gt;();</span>
<span class="fc bfc" id="L3004" title="All 2 branches covered.">                            for (FiredTriggerRecord ft : acquired) {</span>
<span class="fc bfc" id="L3005" title="All 2 branches covered.">                                if (STATE_EXECUTING.equals(ft.getFireInstanceState())) {</span>
<span class="fc" id="L3006">                                    executingTriggers.add(ft.getFireInstanceId());</span>
                                }
<span class="fc" id="L3008">                            }</span>
<span class="fc bfc" id="L3009" title="All 2 branches covered.">                            for (TriggerFiredResult tr : result) {</span>
<span class="fc bfc" id="L3010" title="All 4 branches covered.">                                if (tr.getTriggerFiredBundle() != null &amp;&amp; executingTriggers.contains(tr.getTriggerFiredBundle().getTrigger().getFireInstanceId())) {</span>
<span class="fc" id="L3011">                                    return true;</span>
                                }
<span class="fc" id="L3013">                            }</span>
<span class="fc" id="L3014">                            return false;</span>
<span class="fc" id="L3015">                        } catch (SQLException e) {</span>
<span class="fc" id="L3016">                            throw new JobPersistenceException(&quot;error validating trigger acquisition&quot;, e);</span>
                        }
                    }
                });
    }

    protected TriggerFiredBundle triggerFired(Connection conn,
            OperableTrigger trigger)
        throws JobPersistenceException {
        JobDetail job;
<span class="fc" id="L3026">        Calendar cal = null;</span>

        // Make sure trigger wasn't deleted, paused, or completed...
        try { // if trigger was deleted, state will be STATE_DELETED
<span class="fc" id="L3030">            String state = getDelegate().selectTriggerState(conn,</span>
<span class="fc" id="L3031">                    trigger.getKey());</span>
<span class="fc bfc" id="L3032" title="All 2 branches covered.">            if (!state.equals(STATE_ACQUIRED)) {</span>
<span class="fc" id="L3033">                return null;</span>
            }
<span class="fc" id="L3035">        } catch (SQLException e) {</span>
<span class="fc" id="L3036">            throw new JobPersistenceException(&quot;Couldn't select trigger state: &quot;</span>
<span class="fc" id="L3037">                    + e.getMessage(), e);</span>
<span class="fc" id="L3038">        }</span>

        try {
<span class="fc" id="L3041">            job = retrieveJob(conn, trigger.getJobKey());</span>
<span class="pc bpc" id="L3042" title="1 of 2 branches missed.">            if (job == null) { return null; }</span>
<span class="nc" id="L3043">        } catch (JobPersistenceException jpe) {</span>
            try {
<span class="nc" id="L3045">                getLog().error(&quot;Error retrieving job, setting trigger state to ERROR.&quot;, jpe);</span>
<span class="nc" id="L3046">                getDelegate().updateTriggerState(conn, trigger.getKey(),</span>
                        STATE_ERROR);
<span class="nc" id="L3048">            } catch (SQLException sqle) {</span>
<span class="nc" id="L3049">                getLog().error(&quot;Unable to set trigger state to ERROR.&quot;, sqle);</span>
<span class="nc" id="L3050">            }</span>
<span class="nc" id="L3051">            throw jpe;</span>
<span class="fc" id="L3052">        }</span>

<span class="pc bpc" id="L3054" title="1 of 2 branches missed.">        if (trigger.getCalendarName() != null) {</span>
<span class="nc" id="L3055">            cal = retrieveCalendar(conn, trigger.getCalendarName());</span>
<span class="nc bnc" id="L3056" title="All 2 branches missed.">            if (cal == null) { return null; }</span>
        }

        try {
<span class="fc" id="L3060">            getDelegate().updateFiredTrigger(conn, trigger, STATE_EXECUTING, job);</span>
<span class="nc" id="L3061">        } catch (SQLException e) {</span>
<span class="nc" id="L3062">            throw new JobPersistenceException(&quot;Couldn't insert fired trigger: &quot;</span>
<span class="nc" id="L3063">                    + e.getMessage(), e);</span>
<span class="fc" id="L3064">        }</span>

<span class="fc" id="L3066">        Date prevFireTime = trigger.getPreviousFireTime();</span>

        // call triggered - to update the trigger's next-fire-time state...
<span class="fc" id="L3069">        trigger.triggered(cal);</span>

<span class="fc" id="L3071">        String state = STATE_WAITING;</span>
<span class="fc" id="L3072">        boolean force = true;</span>
        
<span class="fc bfc" id="L3074" title="All 2 branches covered.">        if (job.isConcurrentExectionDisallowed()) {</span>
<span class="fc" id="L3075">            state = STATE_BLOCKED;</span>
<span class="fc" id="L3076">            force = false;</span>
            try {
<span class="fc" id="L3078">                getDelegate().updateTriggerStatesForJobFromOtherState(conn, job.getKey(),</span>
                        STATE_BLOCKED, STATE_WAITING);
<span class="fc" id="L3080">                getDelegate().updateTriggerStatesForJobFromOtherState(conn, job.getKey(),</span>
                        STATE_BLOCKED, STATE_ACQUIRED);
<span class="fc" id="L3082">                getDelegate().updateTriggerStatesForJobFromOtherState(conn, job.getKey(),</span>
                        STATE_PAUSED_BLOCKED, STATE_PAUSED);
<span class="nc" id="L3084">            } catch (SQLException e) {</span>
<span class="nc" id="L3085">                throw new JobPersistenceException(</span>
                        &quot;Couldn't update states of blocked triggers: &quot;
<span class="nc" id="L3087">                                + e.getMessage(), e);</span>
<span class="fc" id="L3088">            }</span>
        } 
            
<span class="fc bfc" id="L3091" title="All 2 branches covered.">        if (trigger.getNextFireTime() == null) {</span>
<span class="fc" id="L3092">            state = STATE_COMPLETE;</span>
<span class="fc" id="L3093">            force = true;</span>
        }

<span class="fc" id="L3096">        storeTrigger(conn, trigger, job, true, state, force, false);</span>

<span class="fc" id="L3098">        job.getJobDataMap().clearDirtyFlag();</span>

<span class="fc" id="L3100">        return new TriggerFiredBundle(job, trigger, cal, trigger.getKey().getGroup()</span>
<span class="fc" id="L3101">                .equals(Scheduler.DEFAULT_RECOVERY_GROUP), new Date(), trigger</span>
<span class="fc" id="L3102">                .getPreviousFireTime(), prevFireTime, trigger.getNextFireTime());</span>
    }

    /**
     * &lt;p&gt;
     * Inform the &lt;code&gt;JobStore&lt;/code&gt; that the scheduler has completed the
     * firing of the given &lt;code&gt;Trigger&lt;/code&gt; (and the execution its
     * associated &lt;code&gt;Job&lt;/code&gt;), and that the &lt;code&gt;{@link org.quartz.JobDataMap}&lt;/code&gt;
     * in the given &lt;code&gt;JobDetail&lt;/code&gt; should be updated if the &lt;code&gt;Job&lt;/code&gt;
     * is stateful.
     * &lt;/p&gt;
     */
    public void triggeredJobComplete(final OperableTrigger trigger,
            final JobDetail jobDetail, final CompletedExecutionInstruction triggerInstCode) {
<span class="fc" id="L3116">        retryExecuteInNonManagedTXLock(</span>
            LOCK_TRIGGER_ACCESS,
<span class="fc" id="L3118">            new VoidTransactionCallback() {</span>
                public void executeVoid(Connection conn) throws JobPersistenceException {
<span class="fc" id="L3120">                    triggeredJobComplete(conn, trigger, jobDetail,triggerInstCode);</span>
<span class="fc" id="L3121">                }</span>
            });    
<span class="fc" id="L3123">    }</span>
    
    protected void triggeredJobComplete(Connection conn,
            OperableTrigger trigger, JobDetail jobDetail,
            CompletedExecutionInstruction triggerInstCode) throws JobPersistenceException {
        try {
<span class="fc bfc" id="L3129" title="All 2 branches covered.">            if (triggerInstCode == CompletedExecutionInstruction.DELETE_TRIGGER) {</span>
<span class="pc bpc" id="L3130" title="1 of 2 branches missed.">                if(trigger.getNextFireTime() == null) { </span>
                    // double check for possible reschedule within job 
                    // execution, which would cancel the need to delete...
<span class="fc" id="L3133">                    TriggerStatus stat = getDelegate().selectTriggerStatus(</span>
<span class="fc" id="L3134">                            conn, trigger.getKey());</span>
<span class="pc bpc" id="L3135" title="1 of 4 branches missed.">                    if(stat != null &amp;&amp; stat.getNextFireTime() == null) {</span>
<span class="fc" id="L3136">                        removeTrigger(conn, trigger.getKey());</span>
                    }
<span class="fc" id="L3138">                } else{</span>
<span class="nc" id="L3139">                    removeTrigger(conn, trigger.getKey());</span>
<span class="nc" id="L3140">                    signalSchedulingChangeOnTxCompletion(0L);</span>
                }
<span class="pc bpc" id="L3142" title="1 of 2 branches missed.">            } else if (triggerInstCode == CompletedExecutionInstruction.SET_TRIGGER_COMPLETE) {</span>
<span class="nc" id="L3143">                getDelegate().updateTriggerState(conn, trigger.getKey(),</span>
                        STATE_COMPLETE);
<span class="nc" id="L3145">                signalSchedulingChangeOnTxCompletion(0L);</span>
<span class="fc bfc" id="L3146" title="All 2 branches covered.">            } else if (triggerInstCode == CompletedExecutionInstruction.SET_TRIGGER_ERROR) {</span>
<span class="fc" id="L3147">                getLog().info(&quot;Trigger &quot; + trigger.getKey() + &quot; set to ERROR state.&quot;);</span>
<span class="fc" id="L3148">                getDelegate().updateTriggerState(conn, trigger.getKey(),</span>
                        STATE_ERROR);
<span class="fc" id="L3150">                signalSchedulingChangeOnTxCompletion(0L);</span>
<span class="pc bpc" id="L3151" title="1 of 2 branches missed.">            } else if (triggerInstCode == CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_COMPLETE) {</span>
<span class="nc" id="L3152">                getDelegate().updateTriggerStatesForJob(conn,</span>
<span class="nc" id="L3153">                        trigger.getJobKey(), STATE_COMPLETE);</span>
<span class="nc" id="L3154">                signalSchedulingChangeOnTxCompletion(0L);</span>
<span class="pc bpc" id="L3155" title="1 of 2 branches missed.">            } else if (triggerInstCode == CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR) {</span>
<span class="nc" id="L3156">                getLog().info(&quot;All triggers of Job &quot; + </span>
<span class="nc" id="L3157">                        trigger.getKey() + &quot; set to ERROR state.&quot;);</span>
<span class="nc" id="L3158">                getDelegate().updateTriggerStatesForJob(conn,</span>
<span class="nc" id="L3159">                        trigger.getJobKey(), STATE_ERROR);</span>
<span class="nc" id="L3160">                signalSchedulingChangeOnTxCompletion(0L);</span>
            }

<span class="fc bfc" id="L3163" title="All 2 branches covered.">            if (jobDetail.isConcurrentExectionDisallowed()) {</span>
<span class="fc" id="L3164">                getDelegate().updateTriggerStatesForJobFromOtherState(conn,</span>
<span class="fc" id="L3165">                        jobDetail.getKey(), STATE_WAITING,</span>
                        STATE_BLOCKED);

<span class="fc" id="L3168">                getDelegate().updateTriggerStatesForJobFromOtherState(conn,</span>
<span class="fc" id="L3169">                        jobDetail.getKey(), STATE_PAUSED,</span>
                        STATE_PAUSED_BLOCKED);

<span class="fc" id="L3172">                signalSchedulingChangeOnTxCompletion(0L);</span>
            }
<span class="fc bfc" id="L3174" title="All 2 branches covered.">            if (jobDetail.isPersistJobDataAfterExecution()) {</span>
                try {
<span class="pc bpc" id="L3176" title="1 of 2 branches missed.">                    if (jobDetail.getJobDataMap().isDirty()) {</span>
<span class="fc" id="L3177">                        getDelegate().updateJobData(conn, jobDetail);</span>
                    }
<span class="nc" id="L3179">                } catch (IOException e) {</span>
<span class="nc" id="L3180">                    throw new JobPersistenceException(</span>
<span class="nc" id="L3181">                            &quot;Couldn't serialize job data: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L3182">                } catch (SQLException e) {</span>
<span class="nc" id="L3183">                    throw new JobPersistenceException(</span>
<span class="nc" id="L3184">                            &quot;Couldn't update job data: &quot; + e.getMessage(), e);</span>
<span class="fc" id="L3185">                }</span>
            }
<span class="nc" id="L3187">        } catch (SQLException e) {</span>
<span class="nc" id="L3188">            throw new JobPersistenceException(</span>
<span class="nc" id="L3189">                    &quot;Couldn't update trigger state(s): &quot; + e.getMessage(), e);</span>
<span class="fc" id="L3190">        }</span>

        try {
<span class="fc" id="L3193">            getDelegate().deleteFiredTrigger(conn, trigger.getFireInstanceId());</span>
<span class="nc" id="L3194">        } catch (SQLException e) {</span>
<span class="nc" id="L3195">            throw new JobPersistenceException(&quot;Couldn't delete fired trigger: &quot;</span>
<span class="nc" id="L3196">                    + e.getMessage(), e);</span>
<span class="fc" id="L3197">        }</span>
<span class="fc" id="L3198">    }</span>

    /**
     * &lt;P&gt;
     * Get the driver delegate for DB operations.
     * &lt;/p&gt;
     */
    protected DriverDelegate getDelegate() throws NoSuchDelegateException {
<span class="fc" id="L3206">        synchronized(this) {</span>
<span class="fc bfc" id="L3207" title="All 2 branches covered.">            if(null == delegate) {</span>
                try {
<span class="fc bfc" id="L3209" title="All 2 branches covered.">                    if(delegateClassName != null) {</span>
<span class="fc" id="L3210">                        delegateClass = getClassLoadHelper().loadClass(delegateClassName, DriverDelegate.class);</span>
                    }

<span class="fc" id="L3213">                    delegate = delegateClass.newInstance();</span>
                    
<span class="fc" id="L3215">                    delegate.initialize(getLog(), tablePrefix, instanceName, instanceId, getClassLoadHelper(), canUseProperties(), getDriverDelegateInitString());</span>
                    
<span class="nc" id="L3217">                } catch (InstantiationException e) {</span>
<span class="nc" id="L3218">                    throw new NoSuchDelegateException(&quot;Couldn't create delegate: &quot;</span>
<span class="nc" id="L3219">                            + e.getMessage(), e);</span>
<span class="nc" id="L3220">                } catch (IllegalAccessException e) {</span>
<span class="nc" id="L3221">                    throw new NoSuchDelegateException(&quot;Couldn't create delegate: &quot;</span>
<span class="nc" id="L3222">                            + e.getMessage(), e);</span>
<span class="nc" id="L3223">                } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L3224">                    throw new NoSuchDelegateException(&quot;Couldn't load delegate class: &quot;</span>
<span class="nc" id="L3225">                            + e.getMessage(), e);</span>
<span class="fc" id="L3226">                }</span>
            }
<span class="fc" id="L3228">            return delegate;</span>
        }
    }

    protected Semaphore getLockHandler() {
<span class="fc" id="L3233">        return lockHandler;</span>
    }

    public void setLockHandler(Semaphore lockHandler) {
<span class="fc" id="L3237">        this.lockHandler = lockHandler;</span>
<span class="fc" id="L3238">    }</span>

    //---------------------------------------------------------------------------
    // Management methods
    //---------------------------------------------------------------------------

    protected RecoverMisfiredJobsResult doRecoverMisfires() throws JobPersistenceException {
<span class="fc" id="L3245">        boolean transOwner = false;</span>
<span class="fc" id="L3246">        Connection conn = getNonManagedTXConnection();</span>
        try {
<span class="fc" id="L3248">            RecoverMisfiredJobsResult result = RecoverMisfiredJobsResult.NO_OP;</span>
            
            // Before we make the potentially expensive call to acquire the 
            // trigger lock, peek ahead to see if it is likely we would find
            // misfired triggers requiring recovery.
<span class="pc bpc" id="L3253" title="1 of 2 branches missed.">            int misfireCount = (getDoubleCheckLockMisfireHandler()) ?</span>
<span class="pc" id="L3254">                getDelegate().countMisfiredTriggersInState(</span>
<span class="fc" id="L3255">                    conn, STATE_WAITING, getMisfireTime()) : </span>
                Integer.MAX_VALUE;
            
<span class="fc bfc" id="L3258" title="All 2 branches covered.">            if (misfireCount == 0) {</span>
<span class="fc" id="L3259">                getLog().debug(</span>
                    &quot;Found 0 triggers that missed their scheduled fire-time.&quot;);
            } else {
<span class="fc" id="L3262">                transOwner = getLockHandler().obtainLock(conn, LOCK_TRIGGER_ACCESS);</span>
                
<span class="fc" id="L3264">                result = recoverMisfiredJobs(conn, false);</span>
            }
            
<span class="fc" id="L3267">            commitConnection(conn);</span>
<span class="fc" id="L3268">            return result;</span>
<span class="fc" id="L3269">        } catch (JobPersistenceException e) {</span>
<span class="fc" id="L3270">            rollbackConnection(conn);</span>
<span class="fc" id="L3271">            throw e;</span>
<span class="fc" id="L3272">        } catch (SQLException e) {</span>
<span class="fc" id="L3273">            rollbackConnection(conn);</span>
<span class="fc" id="L3274">            throw new JobPersistenceException(&quot;Database error recovering from misfires.&quot;, e);</span>
<span class="nc" id="L3275">        } catch (RuntimeException e) {</span>
<span class="nc" id="L3276">            rollbackConnection(conn);</span>
<span class="nc" id="L3277">            throw new JobPersistenceException(&quot;Unexpected runtime exception: &quot;</span>
<span class="nc" id="L3278">                    + e.getMessage(), e);</span>
        } finally {
            try {
<span class="fc" id="L3281">                releaseLock(LOCK_TRIGGER_ACCESS, transOwner);</span>
            } finally {
<span class="fc" id="L3283">                cleanupConnection(conn);</span>
            }
        }
    }

<span class="fc" id="L3288">    protected ThreadLocal&lt;Long&gt; sigChangeForTxCompletion = new ThreadLocal&lt;Long&gt;();</span>
    protected void signalSchedulingChangeOnTxCompletion(long candidateNewNextFireTime) {
<span class="fc" id="L3290">        Long sigTime = sigChangeForTxCompletion.get();</span>
<span class="pc bpc" id="L3291" title="1 of 4 branches missed.">        if(sigTime == null &amp;&amp; candidateNewNextFireTime &gt;= 0L)</span>
<span class="fc" id="L3292">            sigChangeForTxCompletion.set(candidateNewNextFireTime);</span>
        else {
<span class="pc bpc" id="L3294" title="2 of 4 branches missed.">            if(sigTime == null || candidateNewNextFireTime &lt; sigTime)</span>
<span class="nc" id="L3295">                sigChangeForTxCompletion.set(candidateNewNextFireTime);</span>
        }
<span class="fc" id="L3297">    }</span>
    
    protected Long clearAndGetSignalSchedulingChangeOnTxCompletion() {
<span class="fc" id="L3300">        Long t = sigChangeForTxCompletion.get();</span>
<span class="fc" id="L3301">        sigChangeForTxCompletion.set(null);</span>
<span class="fc" id="L3302">        return t;</span>
    }

    protected void signalSchedulingChangeImmediately(long candidateNewNextFireTime) {
<span class="fc" id="L3306">        schedSignaler.signalSchedulingChange(candidateNewNextFireTime);</span>
<span class="fc" id="L3307">    }</span>

    //---------------------------------------------------------------------------
    // Cluster management methods
    //---------------------------------------------------------------------------

<span class="fc" id="L3313">    protected boolean firstCheckIn = true;</span>

<span class="fc" id="L3315">    protected long lastCheckin = System.currentTimeMillis();</span>
    
    protected boolean doCheckin() throws JobPersistenceException {
<span class="nc" id="L3318">        boolean transOwner = false;</span>
<span class="nc" id="L3319">        boolean transStateOwner = false;</span>
<span class="nc" id="L3320">        boolean recovered = false;</span>

<span class="nc" id="L3322">        Connection conn = getNonManagedTXConnection();</span>
        try {
            // Other than the first time, always checkin first to make sure there is 
            // work to be done before we acquire the lock (since that is expensive, 
            // and is almost never necessary).  This must be done in a separate
            // transaction to prevent a deadlock under recovery conditions.
<span class="nc" id="L3328">            List&lt;SchedulerStateRecord&gt; failedRecords = null;</span>
<span class="nc bnc" id="L3329" title="All 2 branches missed.">            if (!firstCheckIn) {</span>
<span class="nc" id="L3330">                failedRecords = clusterCheckIn(conn);</span>
<span class="nc" id="L3331">                commitConnection(conn);</span>
            }
            
<span class="nc bnc" id="L3334" title="All 4 branches missed.">            if (firstCheckIn || (failedRecords.size() &gt; 0)) {</span>
<span class="nc" id="L3335">                getLockHandler().obtainLock(conn, LOCK_STATE_ACCESS);</span>
<span class="nc" id="L3336">                transStateOwner = true;</span>
    
                // Now that we own the lock, make sure we still have work to do. 
                // The first time through, we also need to make sure we update/create our state record
<span class="nc bnc" id="L3340" title="All 2 branches missed.">                failedRecords = (firstCheckIn) ? clusterCheckIn(conn) : findFailedInstances(conn);</span>
    
<span class="nc bnc" id="L3342" title="All 2 branches missed.">                if (failedRecords.size() &gt; 0) {</span>
<span class="nc" id="L3343">                    getLockHandler().obtainLock(conn, LOCK_TRIGGER_ACCESS);</span>
                    //getLockHandler().obtainLock(conn, LOCK_JOB_ACCESS);
<span class="nc" id="L3345">                    transOwner = true;</span>
    
<span class="nc" id="L3347">                    clusterRecover(conn, failedRecords);</span>
<span class="nc" id="L3348">                    recovered = true;</span>
                }
            }
            
<span class="nc" id="L3352">            commitConnection(conn);</span>
<span class="nc" id="L3353">        } catch (JobPersistenceException e) {</span>
<span class="nc" id="L3354">            rollbackConnection(conn);</span>
<span class="nc" id="L3355">            throw e;</span>
        } finally {
            try {
<span class="nc" id="L3358">                releaseLock(LOCK_TRIGGER_ACCESS, transOwner);</span>
            } finally {
                try {
<span class="nc" id="L3361">                    releaseLock(LOCK_STATE_ACCESS, transStateOwner);</span>
                } finally {
<span class="nc" id="L3363">                    cleanupConnection(conn);</span>
                }
            }
        }

<span class="nc" id="L3368">        firstCheckIn = false;</span>

<span class="nc" id="L3370">        return recovered;</span>
    }

    /**
     * Get a list of all scheduler instances in the cluster that may have failed.
     * This includes this scheduler if it is checking in for the first time.
     */
    protected List&lt;SchedulerStateRecord&gt; findFailedInstances(Connection conn)
        throws JobPersistenceException {
        try {
<span class="nc" id="L3380">            List&lt;SchedulerStateRecord&gt; failedInstances = new LinkedList&lt;SchedulerStateRecord&gt;();</span>
<span class="nc" id="L3381">            boolean foundThisScheduler = false;</span>
<span class="nc" id="L3382">            long timeNow = System.currentTimeMillis();</span>
            
<span class="nc" id="L3384">            List&lt;SchedulerStateRecord&gt; states = getDelegate().selectSchedulerStateRecords(conn, null);</span>

<span class="nc bnc" id="L3386" title="All 2 branches missed.">            for(SchedulerStateRecord rec: states) {</span>
        
                // find own record...
<span class="nc bnc" id="L3389" title="All 2 branches missed.">                if (rec.getSchedulerInstanceId().equals(getInstanceId())) {</span>
<span class="nc" id="L3390">                    foundThisScheduler = true;</span>
<span class="nc bnc" id="L3391" title="All 2 branches missed.">                    if (firstCheckIn) {</span>
<span class="nc" id="L3392">                        failedInstances.add(rec);</span>
                    }
                } else {
                    // find failed instances...
<span class="nc bnc" id="L3396" title="All 2 branches missed.">                    if (calcFailedIfAfter(rec) &lt; timeNow) {</span>
<span class="nc" id="L3397">                        failedInstances.add(rec);</span>
                    }
                }
<span class="nc" id="L3400">            }</span>
            
            // The first time through, also check for orphaned fired triggers.
<span class="nc bnc" id="L3403" title="All 2 branches missed.">            if (firstCheckIn) {</span>
<span class="nc" id="L3404">                failedInstances.addAll(findOrphanedFailedInstances(conn, states));</span>
            }
            
            // If not the first time but we didn't find our own instance, then
            // Someone must have done recovery for us.
<span class="nc bnc" id="L3409" title="All 4 branches missed.">            if ((!foundThisScheduler) &amp;&amp; (!firstCheckIn)) {</span>
                // FUTURE_TODO: revisit when handle self-failed-out impl'ed (see FUTURE_TODO in clusterCheckIn() below)
<span class="nc" id="L3411">                getLog().warn(</span>
<span class="nc" id="L3412">                    &quot;This scheduler instance (&quot; + getInstanceId() + &quot;) is still &quot; + </span>
                    &quot;active but was recovered by another instance in the cluster.  &quot; +
                    &quot;This may cause inconsistent behavior.&quot;);
            }
            
<span class="nc" id="L3417">            return failedInstances;</span>
<span class="nc" id="L3418">        } catch (Exception e) {</span>
<span class="nc" id="L3419">            lastCheckin = System.currentTimeMillis();</span>
<span class="nc" id="L3420">            throw new JobPersistenceException(&quot;Failure identifying failed instances when checking-in: &quot;</span>
<span class="nc" id="L3421">                    + e.getMessage(), e);</span>
        }
    }
    
    /**
     * Create dummy &lt;code&gt;SchedulerStateRecord&lt;/code&gt; objects for fired triggers
     * that have no scheduler state record.  Checkin timestamp and interval are
     * left as zero on these dummy &lt;code&gt;SchedulerStateRecord&lt;/code&gt; objects.
     * 
     * @param schedulerStateRecords List of all current &lt;code&gt;SchedulerStateRecords&lt;/code&gt;
     */
    private List&lt;SchedulerStateRecord&gt; findOrphanedFailedInstances(
            Connection conn, 
            List&lt;SchedulerStateRecord&gt; schedulerStateRecords) 
        throws SQLException, NoSuchDelegateException {
<span class="nc" id="L3436">        List&lt;SchedulerStateRecord&gt; orphanedInstances = new ArrayList&lt;SchedulerStateRecord&gt;();</span>
        
<span class="nc" id="L3438">        Set&lt;String&gt; allFiredTriggerInstanceNames = getDelegate().selectFiredTriggerInstanceNames(conn);</span>
<span class="nc bnc" id="L3439" title="All 2 branches missed.">        if (!allFiredTriggerInstanceNames.isEmpty()) {</span>
<span class="nc bnc" id="L3440" title="All 2 branches missed.">            for (SchedulerStateRecord rec: schedulerStateRecords) {</span>
                
<span class="nc" id="L3442">                allFiredTriggerInstanceNames.remove(rec.getSchedulerInstanceId());</span>
<span class="nc" id="L3443">            }</span>
            
<span class="nc bnc" id="L3445" title="All 2 branches missed.">            for (String inst: allFiredTriggerInstanceNames) {</span>
                
<span class="nc" id="L3447">                SchedulerStateRecord orphanedInstance = new SchedulerStateRecord();</span>
<span class="nc" id="L3448">                orphanedInstance.setSchedulerInstanceId(inst);</span>
                
<span class="nc" id="L3450">                orphanedInstances.add(orphanedInstance);</span>
                
<span class="nc" id="L3452">                getLog().warn(</span>
<span class="nc" id="L3453">                    &quot;Found orphaned fired triggers for instance: &quot; + orphanedInstance.getSchedulerInstanceId());</span>
<span class="nc" id="L3454">            }</span>
        }
        
<span class="nc" id="L3457">        return orphanedInstances;</span>
    }
    
    protected long calcFailedIfAfter(SchedulerStateRecord rec) {
<span class="nc" id="L3461">        return rec.getCheckinTimestamp() +</span>
<span class="nc" id="L3462">            Math.max(rec.getCheckinInterval(), </span>
<span class="nc" id="L3463">                    (System.currentTimeMillis() - lastCheckin)) +</span>
            7500L;
    }
    
    protected List&lt;SchedulerStateRecord&gt; clusterCheckIn(Connection conn)
        throws JobPersistenceException {

<span class="nc" id="L3470">        List&lt;SchedulerStateRecord&gt; failedInstances = findFailedInstances(conn);</span>
        
        try {
            // FUTURE_TODO: handle self-failed-out

            // check in...
<span class="nc" id="L3476">            lastCheckin = System.currentTimeMillis();</span>
<span class="nc bnc" id="L3477" title="All 2 branches missed.">            if(getDelegate().updateSchedulerState(conn, getInstanceId(), lastCheckin) == 0) {</span>
<span class="nc" id="L3478">                getDelegate().insertSchedulerState(conn, getInstanceId(),</span>
<span class="nc" id="L3479">                        lastCheckin, getClusterCheckinInterval());</span>
            }
            
<span class="nc" id="L3482">        } catch (Exception e) {</span>
<span class="nc" id="L3483">            throw new JobPersistenceException(&quot;Failure updating scheduler state when checking-in: &quot;</span>
<span class="nc" id="L3484">                    + e.getMessage(), e);</span>
<span class="nc" id="L3485">        }</span>

<span class="nc" id="L3487">        return failedInstances;</span>
    }

    @SuppressWarnings(&quot;ConstantConditions&quot;)
    protected void clusterRecover(Connection conn, List&lt;SchedulerStateRecord&gt; failedInstances)
        throws JobPersistenceException {

<span class="nc bnc" id="L3494" title="All 2 branches missed.">        if (failedInstances.size() &gt; 0) {</span>

<span class="nc" id="L3496">            long recoverIds = System.currentTimeMillis();</span>

<span class="nc" id="L3498">            logWarnIfNonZero(failedInstances.size(),</span>
<span class="nc" id="L3499">                    &quot;ClusterManager: detected &quot; + failedInstances.size()</span>
                            + &quot; failed or restarted instances.&quot;);
            try {
<span class="nc bnc" id="L3502" title="All 2 branches missed.">                for (SchedulerStateRecord rec : failedInstances) {</span>
<span class="nc" id="L3503">                    getLog().info(</span>
                            &quot;ClusterManager: Scanning for instance \&quot;&quot;
<span class="nc" id="L3505">                                    + rec.getSchedulerInstanceId()</span>
                                    + &quot;\&quot;'s failed in-progress jobs.&quot;);

<span class="nc" id="L3508">                    List&lt;FiredTriggerRecord&gt; firedTriggerRecs = getDelegate()</span>
<span class="nc" id="L3509">                            .selectInstancesFiredTriggerRecords(conn,</span>
<span class="nc" id="L3510">                                    rec.getSchedulerInstanceId());</span>

<span class="nc" id="L3512">                    int acquiredCount = 0;</span>
<span class="nc" id="L3513">                    int recoveredCount = 0;</span>
<span class="nc" id="L3514">                    int otherCount = 0;</span>

<span class="nc" id="L3516">                    Set&lt;TriggerKey&gt; triggerKeys = new HashSet&lt;TriggerKey&gt;();</span>

<span class="nc bnc" id="L3518" title="All 2 branches missed.">                    for (FiredTriggerRecord ftRec : firedTriggerRecs) {</span>

<span class="nc" id="L3520">                        TriggerKey tKey = ftRec.getTriggerKey();</span>
<span class="nc" id="L3521">                        JobKey jKey = ftRec.getJobKey();</span>

<span class="nc" id="L3523">                        triggerKeys.add(tKey);</span>

                        // release blocked triggers..
<span class="nc bnc" id="L3526" title="All 2 branches missed.">                        if (ftRec.getFireInstanceState().equals(STATE_BLOCKED)) {</span>
<span class="nc" id="L3527">                            getDelegate()</span>
<span class="nc" id="L3528">                                    .updateTriggerStatesForJobFromOtherState(</span>
                                            conn, jKey,
                                            STATE_WAITING, STATE_BLOCKED);
<span class="nc bnc" id="L3531" title="All 2 branches missed.">                        } else if (ftRec.getFireInstanceState().equals(STATE_PAUSED_BLOCKED)) {</span>
<span class="nc" id="L3532">                            getDelegate()</span>
<span class="nc" id="L3533">                                    .updateTriggerStatesForJobFromOtherState(</span>
                                            conn, jKey,
                                            STATE_PAUSED, STATE_PAUSED_BLOCKED);
                        }

                        // release acquired triggers..
<span class="nc bnc" id="L3539" title="All 2 branches missed.">                        if (ftRec.getFireInstanceState().equals(STATE_ACQUIRED)) {</span>
<span class="nc" id="L3540">                            getDelegate().updateTriggerStateFromOtherState(</span>
                                    conn, tKey, STATE_WAITING,
                                    STATE_ACQUIRED);
<span class="nc" id="L3543">                            acquiredCount++;</span>
<span class="nc bnc" id="L3544" title="All 2 branches missed.">                        } else if (ftRec.isJobRequestsRecovery()) {</span>
                            // handle jobs marked for recovery that were not fully
                            // executed..
<span class="nc bnc" id="L3547" title="All 2 branches missed.">                            if (jobExists(conn, jKey)) {</span>
                                @SuppressWarnings(&quot;deprecation&quot;)
<span class="nc" id="L3549">                                SimpleTriggerImpl rcvryTrig = new SimpleTriggerImpl(</span>
                                        &quot;recover_&quot;
<span class="nc" id="L3551">                                                + rec.getSchedulerInstanceId()</span>
                                                + &quot;_&quot;
<span class="nc" id="L3553">                                                + String.valueOf(recoverIds++),</span>
                                        Scheduler.DEFAULT_RECOVERY_GROUP,
<span class="nc" id="L3555">                                        new Date(ftRec.getScheduleTimestamp()));</span>
<span class="nc" id="L3556">                                rcvryTrig.setJobName(jKey.getName());</span>
<span class="nc" id="L3557">                                rcvryTrig.setJobGroup(jKey.getGroup());</span>
<span class="nc" id="L3558">                                rcvryTrig.setMisfireInstruction(SimpleTrigger.MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY);</span>
<span class="nc" id="L3559">                                rcvryTrig.setPriority(ftRec.getPriority());</span>
<span class="nc" id="L3560">                                JobDataMap jd = getDelegate().selectTriggerJobDataMap(conn, tKey.getName(), tKey.getGroup());</span>
<span class="nc" id="L3561">                                jd.put(Scheduler.FAILED_JOB_ORIGINAL_TRIGGER_NAME, tKey.getName());</span>
<span class="nc" id="L3562">                                jd.put(Scheduler.FAILED_JOB_ORIGINAL_TRIGGER_GROUP, tKey.getGroup());</span>
<span class="nc" id="L3563">                                jd.put(Scheduler.FAILED_JOB_ORIGINAL_TRIGGER_FIRETIME_IN_MILLISECONDS, String.valueOf(ftRec.getFireTimestamp()));</span>
<span class="nc" id="L3564">                                jd.put(Scheduler.FAILED_JOB_ORIGINAL_TRIGGER_SCHEDULED_FIRETIME_IN_MILLISECONDS, String.valueOf(ftRec.getScheduleTimestamp()));</span>
<span class="nc" id="L3565">                                rcvryTrig.setJobDataMap(jd);</span>

<span class="nc" id="L3567">                                rcvryTrig.computeFirstFireTime(null);</span>
<span class="nc" id="L3568">                                storeTrigger(conn, rcvryTrig, null, false,</span>
                                        STATE_WAITING, false, true);
<span class="nc" id="L3570">                                recoveredCount++;</span>
<span class="nc" id="L3571">                            } else {</span>
<span class="nc" id="L3572">                                getLog()</span>
<span class="nc" id="L3573">                                        .warn(</span>
                                                &quot;ClusterManager: failed job '&quot;
                                                        + jKey
                                                        + &quot;' no longer exists, cannot schedule recovery.&quot;);
<span class="nc" id="L3577">                                otherCount++;</span>
                            }
                        } else {
<span class="nc" id="L3580">                            otherCount++;</span>
                        }

                        // free up stateful job's triggers
<span class="nc bnc" id="L3584" title="All 2 branches missed.">                        if (ftRec.isJobDisallowsConcurrentExecution()) {</span>
<span class="nc" id="L3585">                            getDelegate()</span>
<span class="nc" id="L3586">                                    .updateTriggerStatesForJobFromOtherState(</span>
                                            conn, jKey,
                                            STATE_WAITING, STATE_BLOCKED);
<span class="nc" id="L3589">                            getDelegate()</span>
<span class="nc" id="L3590">                                    .updateTriggerStatesForJobFromOtherState(</span>
                                            conn, jKey,
                                            STATE_PAUSED, STATE_PAUSED_BLOCKED);
                        }
<span class="nc" id="L3594">                    }</span>

<span class="nc" id="L3596">                    getDelegate().deleteFiredTriggers(conn,</span>
<span class="nc" id="L3597">                            rec.getSchedulerInstanceId());</span>

                    // Check if any of the fired triggers we just deleted were the last fired trigger
                    // records of a COMPLETE trigger.
<span class="nc" id="L3601">                    int completeCount = 0;</span>
<span class="nc bnc" id="L3602" title="All 2 branches missed.">                    for (TriggerKey triggerKey : triggerKeys) {</span>

<span class="nc" id="L3604">                        if (getDelegate().selectTriggerState(conn, triggerKey).</span>
<span class="nc bnc" id="L3605" title="All 2 branches missed.">                                equals(STATE_COMPLETE)) {</span>
<span class="nc" id="L3606">                            List&lt;FiredTriggerRecord&gt; firedTriggers =</span>
<span class="nc" id="L3607">                                    getDelegate().selectFiredTriggerRecords(conn, triggerKey.getName(), triggerKey.getGroup());</span>
<span class="nc bnc" id="L3608" title="All 2 branches missed.">                            if (firedTriggers.isEmpty()) {</span>

<span class="nc bnc" id="L3610" title="All 2 branches missed.">                                if (removeTrigger(conn, triggerKey)) {</span>
<span class="nc" id="L3611">                                    completeCount++;</span>
                                }
                            }
                        }
<span class="nc" id="L3615">                    }</span>

<span class="nc" id="L3617">                    logWarnIfNonZero(acquiredCount,</span>
                            &quot;ClusterManager: ......Freed &quot; + acquiredCount
                                    + &quot; acquired trigger(s).&quot;);
<span class="nc" id="L3620">                    logWarnIfNonZero(completeCount,</span>
                            &quot;ClusterManager: ......Deleted &quot; + completeCount
                                    + &quot; complete triggers(s).&quot;);
<span class="nc" id="L3623">                    logWarnIfNonZero(recoveredCount,</span>
                            &quot;ClusterManager: ......Scheduled &quot; + recoveredCount
                                    + &quot; recoverable job(s) for recovery.&quot;);
<span class="nc" id="L3626">                    logWarnIfNonZero(otherCount,</span>
                            &quot;ClusterManager: ......Cleaned-up &quot; + otherCount
                                    + &quot; other failed job(s).&quot;);

<span class="nc bnc" id="L3630" title="All 2 branches missed.">                    if (!rec.getSchedulerInstanceId().equals(getInstanceId())) {</span>
<span class="nc" id="L3631">                        getDelegate().deleteSchedulerState(conn,</span>
<span class="nc" id="L3632">                                rec.getSchedulerInstanceId());</span>
                    }
<span class="nc" id="L3634">                }</span>
<span class="nc" id="L3635">            } catch (Throwable e) {</span>
<span class="nc" id="L3636">                throw new JobPersistenceException(&quot;Failure recovering jobs: &quot;</span>
<span class="nc" id="L3637">                        + e.getMessage(), e);</span>
<span class="nc" id="L3638">            }</span>
        }
<span class="nc" id="L3640">    }</span>

    protected void logWarnIfNonZero(int val, String warning) {
<span class="nc bnc" id="L3643" title="All 2 branches missed.">        if (val &gt; 0) {</span>
<span class="nc" id="L3644">            getLog().info(warning);</span>
        } else {
<span class="nc" id="L3646">            getLog().debug(warning);</span>
        }
<span class="nc" id="L3648">    }</span>

    /**
     * &lt;p&gt;
     * Cleanup the given database connection.  This means restoring
     * any modified auto commit or transaction isolation connection
     * attributes, and then closing the underlying connection.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * This is separate from closeConnection() because the Spring 
     * integration relies on being able to overload closeConnection() and
     * expects the same connection back that it originally returned
     * from the datasource. 
     * &lt;/p&gt;
     * 
     * @see #closeConnection(Connection)
     */
    protected void cleanupConnection(Connection conn) {
<span class="fc bfc" id="L3667" title="All 2 branches covered.">        if (conn != null) {</span>
<span class="pc bpc" id="L3668" title="1 of 2 branches missed.">            if (conn instanceof Proxy) {</span>
<span class="fc" id="L3669">                Proxy connProxy = (Proxy)conn;</span>
                
<span class="fc" id="L3671">                InvocationHandler invocationHandler = </span>
<span class="fc" id="L3672">                    Proxy.getInvocationHandler(connProxy);</span>
<span class="pc bpc" id="L3673" title="1 of 2 branches missed.">                if (invocationHandler instanceof AttributeRestoringConnectionInvocationHandler) {</span>
<span class="fc" id="L3674">                    AttributeRestoringConnectionInvocationHandler connHandler =</span>
                        (AttributeRestoringConnectionInvocationHandler)invocationHandler;
                        
<span class="fc" id="L3677">                    connHandler.restoreOriginalAtributes();</span>
<span class="fc" id="L3678">                    closeConnection(connHandler.getWrappedConnection());</span>
<span class="fc" id="L3679">                    return;</span>
                }
            }
            
            // Wan't a Proxy, or was a Proxy, but wasn't ours.
<span class="nc" id="L3684">            closeConnection(conn);</span>
        }
<span class="fc" id="L3686">    }</span>
    
    
    /**
     * Closes the supplied &lt;code&gt;Connection&lt;/code&gt;.
     * &lt;p&gt;
     * Ignores a &lt;code&gt;null Connection&lt;/code&gt;.  
     * Any exception thrown trying to close the &lt;code&gt;Connection&lt;/code&gt; is
     * logged and ignored.  
     * &lt;/p&gt;
     * 
     * @param conn The &lt;code&gt;Connection&lt;/code&gt; to close (Optional).
     */
    protected void closeConnection(Connection conn) {
<span class="pc bpc" id="L3700" title="1 of 2 branches missed.">        if (conn != null) {</span>
            try {
<span class="fc" id="L3702">                conn.close();</span>
<span class="nc" id="L3703">            } catch (SQLException e) {</span>
<span class="nc" id="L3704">                getLog().error(&quot;Failed to close Connection&quot;, e);</span>
<span class="nc" id="L3705">            } catch (Throwable e) {</span>
<span class="nc" id="L3706">                getLog().error(</span>
                    &quot;Unexpected exception closing Connection.&quot; +
                    &quot;  This is often due to a Connection being returned after or during shutdown.&quot;, e);
<span class="pc" id="L3709">            }</span>
        }
<span class="fc" id="L3711">    }</span>

    /**
     * Rollback the supplied connection.
     * 
     * &lt;p&gt;  
     * Logs any SQLException it gets trying to rollback, but will not propogate
     * the exception lest it mask the exception that caused the caller to 
     * need to rollback in the first place.
     * &lt;/p&gt;
     *
     * @param conn (Optional)
     */
    protected void rollbackConnection(Connection conn) {
<span class="fc bfc" id="L3725" title="All 2 branches covered.">        if (conn != null) {</span>
            try {
<span class="fc" id="L3727">                conn.rollback();</span>
<span class="fc" id="L3728">            } catch (SQLException e) {</span>
<span class="fc" id="L3729">                getLog().error(</span>
<span class="fc" id="L3730">                    &quot;Couldn't rollback jdbc connection. &quot;+e.getMessage(), e);</span>
<span class="fc" id="L3731">            }</span>
        }
<span class="fc" id="L3733">    }</span>
    
    /**
     * Commit the supplied connection
     *
     * @param conn (Optional)
     * @throws JobPersistenceException thrown if a SQLException occurs when the
     * connection is committed
     */
    protected void commitConnection(Connection conn)
        throws JobPersistenceException {

<span class="pc bpc" id="L3745" title="1 of 2 branches missed.">        if (conn != null) {</span>
            try {
<span class="fc" id="L3747">                conn.commit();</span>
<span class="fc" id="L3748">            } catch (SQLException e) {</span>
<span class="fc" id="L3749">                throw new JobPersistenceException(</span>
<span class="fc" id="L3750">                    &quot;Couldn't commit jdbc connection. &quot;+e.getMessage(), e);</span>
<span class="fc" id="L3751">            }</span>
        }
<span class="fc" id="L3753">    }</span>
    
    /**
     * Implement this interface to provide the code to execute within
     * the a transaction template.  If no return value is required, execute
     * should just return null.
     * 
     * @see JobStoreSupport#executeInNonManagedTXLock(String, TransactionCallback, TransactionValidator)
     * @see JobStoreSupport#executeInLock(String, TransactionCallback)
     * @see JobStoreSupport#executeWithoutLock(TransactionCallback)
     */
    protected interface TransactionCallback&lt;T&gt; {
        T execute(Connection conn) throws JobPersistenceException;
    }

    protected interface TransactionValidator&lt;T&gt; {
        Boolean validate(Connection conn, T result) throws JobPersistenceException;
    }
    
    /**
     * Implement this interface to provide the code to execute within
     * the a transaction template that has no return value.
     * 
     * @see JobStoreSupport#executeInNonManagedTXLock(String, TransactionCallback, TransactionValidator)
     */
<span class="fc" id="L3778">    protected abstract class VoidTransactionCallback implements TransactionCallback&lt;Void&gt; {</span>
        public final Void execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L3780">            executeVoid(conn);</span>
<span class="fc" id="L3781">            return null;</span>
        }
        
        abstract void executeVoid(Connection conn) throws JobPersistenceException;
    }

    /**
     * Execute the given callback in a transaction. Depending on the JobStore, 
     * the surrounding transaction may be assumed to be already present 
     * (managed).  
     * 
     * &lt;p&gt;
     * This method just forwards to executeInLock() with a null lockName.
     * &lt;/p&gt;
     * 
     * @see #executeInLock(String, TransactionCallback)
     */
    public &lt;T&gt; T executeWithoutLock(
        TransactionCallback&lt;T&gt; txCallback) throws JobPersistenceException {
<span class="fc" id="L3800">        return executeInLock(null, txCallback);</span>
    }

    /**
     * Execute the given callback having acquired the given lock.
     * Depending on the JobStore, the surrounding transaction may be 
     * assumed to be already present (managed).
     * 
     * @param lockName The name of the lock to acquire, for example
     * &quot;TRIGGER_ACCESS&quot;.  If null, then no lock is acquired, but the
     * lockCallback is still executed in a transaction. 
     */
    protected abstract &lt;T&gt; T executeInLock(
        String lockName, 
        TransactionCallback&lt;T&gt; txCallback) throws JobPersistenceException;
    
    protected &lt;T&gt; T retryExecuteInNonManagedTXLock(String lockName, TransactionCallback&lt;T&gt; txCallback) {
<span class="fc bfc" id="L3817" title="All 2 branches covered.">        for (int retry = 1; !shutdown; retry++) {</span>
            try {
<span class="fc" id="L3819">                return executeInNonManagedTXLock(lockName, txCallback, null);</span>
<span class="fc" id="L3820">            } catch (JobPersistenceException jpe) {</span>
<span class="fc bfc" id="L3821" title="All 2 branches covered.">                if(retry % 4 == 0) {</span>
<span class="fc" id="L3822">                    schedSignaler.notifySchedulerListenersError(&quot;An error occurred while &quot; + txCallback, jpe);</span>
                }
<span class="nc" id="L3824">            } catch (RuntimeException e) {</span>
<span class="nc" id="L3825">                getLog().error(&quot;retryExecuteInNonManagedTXLock: RuntimeException &quot; + e.getMessage(), e);</span>
<span class="fc" id="L3826">            }</span>
            try {
<span class="fc" id="L3828">                Thread.sleep(getDbRetryInterval()); // retry every N seconds (the db connection must be failed)</span>
<span class="nc" id="L3829">            } catch (InterruptedException e) {</span>
<span class="nc" id="L3830">                throw new IllegalStateException(&quot;Received interrupted exception&quot;, e);</span>
<span class="fc" id="L3831">            }</span>
        }
<span class="fc" id="L3833">        throw new IllegalStateException(&quot;JobStore is shutdown - aborting retry&quot;);</span>
    }
    
    /**
     * Execute the given callback having optionally acquired the given lock.
     * This uses the non-managed transaction connection.
     * 
     * @param lockName The name of the lock to acquire, for example
     * &quot;TRIGGER_ACCESS&quot;.  If null, then no lock is acquired, but the
     * lockCallback is still executed in a non-managed transaction. 
     */
    protected &lt;T&gt; T executeInNonManagedTXLock(
            String lockName, 
            TransactionCallback&lt;T&gt; txCallback, final TransactionValidator&lt;T&gt; txValidator) throws JobPersistenceException {
<span class="fc" id="L3847">        boolean transOwner = false;</span>
<span class="fc" id="L3848">        Connection conn = null;</span>
        try {
<span class="fc bfc" id="L3850" title="All 2 branches covered.">            if (lockName != null) {</span>
                // If we aren't using db locks, then delay getting DB connection 
                // until after acquiring the lock since it isn't needed.
<span class="fc bfc" id="L3853" title="All 2 branches covered.">                if (getLockHandler().requiresConnection()) {</span>
<span class="fc" id="L3854">                    conn = getNonManagedTXConnection();</span>
                }
                
<span class="fc" id="L3857">                transOwner = getLockHandler().obtainLock(conn, lockName);</span>
            }
            
<span class="fc bfc" id="L3860" title="All 2 branches covered.">            if (conn == null) {</span>
<span class="fc" id="L3861">                conn = getNonManagedTXConnection();</span>
            }
            
<span class="fc" id="L3864">            final T result = txCallback.execute(conn);</span>
            try {
<span class="fc" id="L3866">                commitConnection(conn);</span>
<span class="fc" id="L3867">            } catch (JobPersistenceException e) {</span>
<span class="fc" id="L3868">                rollbackConnection(conn);</span>
<span class="fc bfc" id="L3869" title="All 4 branches covered.">                if (txValidator == null || !retryExecuteInNonManagedTXLock(lockName, new TransactionCallback&lt;Boolean&gt;() {</span>
                    @Override
                    public Boolean execute(Connection conn) throws JobPersistenceException {
<span class="fc" id="L3872">                        return txValidator.validate(conn, result);</span>
                    }
                })) {
<span class="fc" id="L3875">                    throw e;</span>
                }
<span class="fc" id="L3877">            }</span>

<span class="fc" id="L3879">            Long sigTime = clearAndGetSignalSchedulingChangeOnTxCompletion();</span>
<span class="pc bpc" id="L3880" title="1 of 4 branches missed.">            if(sigTime != null &amp;&amp; sigTime &gt;= 0) {</span>
<span class="fc" id="L3881">                signalSchedulingChangeImmediately(sigTime);</span>
            }
            
<span class="fc" id="L3884">            return result;</span>
<span class="fc" id="L3885">        } catch (JobPersistenceException e) {</span>
<span class="fc" id="L3886">            rollbackConnection(conn);</span>
<span class="fc" id="L3887">            throw e;</span>
<span class="fc" id="L3888">        } catch (RuntimeException e) {</span>
<span class="nc" id="L3889">            rollbackConnection(conn);</span>
<span class="nc" id="L3890">            throw new JobPersistenceException(&quot;Unexpected runtime exception: &quot;</span>
<span class="nc" id="L3891">                    + e.getMessage(), e);</span>
        } finally {
            try {
<span class="fc" id="L3894">                releaseLock(lockName, transOwner);</span>
            } finally {
<span class="fc" id="L3896">                cleanupConnection(conn);</span>
            }
        }
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    // ClusterManager Thread
    //
    /////////////////////////////////////////////////////////////////////////////

    class ClusterManager extends Thread {

<span class="nc" id="L3909">        private volatile boolean shutdown = false;</span>

<span class="nc" id="L3911">        private int numFails = 0;</span>
        
<span class="nc" id="L3913">        ClusterManager() {</span>
<span class="nc" id="L3914">            this.setPriority(Thread.NORM_PRIORITY + 2);</span>
<span class="nc" id="L3915">            this.setName(&quot;QuartzScheduler_&quot; + instanceName + &quot;-&quot; + instanceId + &quot;_ClusterManager&quot;);</span>
<span class="nc" id="L3916">            this.setDaemon(getMakeThreadsDaemons());</span>
<span class="nc" id="L3917">        }</span>

        public void initialize() {
<span class="nc" id="L3920">            this.manage();</span>

<span class="nc" id="L3922">            ThreadExecutor executor = getThreadExecutor();</span>
<span class="nc" id="L3923">            executor.execute(ClusterManager.this);</span>
<span class="nc" id="L3924">        }</span>

        public void shutdown() {
<span class="nc" id="L3927">            shutdown = true;</span>
<span class="nc" id="L3928">            this.interrupt();</span>
<span class="nc" id="L3929">        }</span>

        private boolean manage() {
<span class="nc" id="L3932">            boolean res = false;</span>
            try {

<span class="nc" id="L3935">                res = doCheckin();</span>

<span class="nc" id="L3937">                numFails = 0;</span>
<span class="nc" id="L3938">                getLog().debug(&quot;ClusterManager: Check-in complete.&quot;);</span>
<span class="nc" id="L3939">            } catch (Exception e) {</span>
<span class="nc bnc" id="L3940" title="All 2 branches missed.">                if(numFails % 4 == 0) {</span>
<span class="nc" id="L3941">                    getLog().error(</span>
                        &quot;ClusterManager: Error managing cluster: &quot;
<span class="nc" id="L3943">                                + e.getMessage(), e);</span>
                }
<span class="nc" id="L3945">                numFails++;</span>
<span class="nc" id="L3946">            }</span>
<span class="nc" id="L3947">            return res;</span>
        }

        @Override
        public void run() {
<span class="nc bnc" id="L3952" title="All 2 branches missed.">            while (!shutdown) {</span>

<span class="nc bnc" id="L3954" title="All 2 branches missed.">                if (!shutdown) {</span>
<span class="nc" id="L3955">                    long timeToSleep = getClusterCheckinInterval();</span>
<span class="nc" id="L3956">                    long transpiredTime = (System.currentTimeMillis() - lastCheckin);</span>
<span class="nc" id="L3957">                    timeToSleep = timeToSleep - transpiredTime;</span>
<span class="nc bnc" id="L3958" title="All 2 branches missed.">                    if (timeToSleep &lt;= 0) {</span>
<span class="nc" id="L3959">                        timeToSleep = 100L;</span>
                    }

<span class="nc bnc" id="L3962" title="All 2 branches missed.">                    if(numFails &gt; 0) {</span>
<span class="nc" id="L3963">                        timeToSleep = Math.max(getDbRetryInterval(), timeToSleep);</span>
                    }
                    
                    try {
<span class="nc" id="L3967">                        Thread.sleep(timeToSleep);</span>
<span class="nc" id="L3968">                    } catch (Exception ignore) {</span>
<span class="nc" id="L3969">                    }</span>
                }

<span class="nc bnc" id="L3972" title="All 4 branches missed.">                if (!shutdown &amp;&amp; this.manage()) {</span>
<span class="nc" id="L3973">                    signalSchedulingChangeImmediately(0L);</span>
                }

            }//while !shutdown
<span class="nc" id="L3977">        }</span>
    }

    /////////////////////////////////////////////////////////////////////////////
    //
    // MisfireHandler Thread
    //
    /////////////////////////////////////////////////////////////////////////////

    class MisfireHandler extends Thread {

<span class="fc" id="L3988">        private volatile boolean shutdown = false;</span>

<span class="fc" id="L3990">        private int numFails = 0;</span>
        

<span class="fc" id="L3993">        MisfireHandler() {</span>
<span class="fc" id="L3994">            this.setName(&quot;QuartzScheduler_&quot; + instanceName + &quot;-&quot; + instanceId + &quot;_MisfireHandler&quot;);</span>
<span class="fc" id="L3995">            this.setDaemon(getMakeThreadsDaemons());</span>
<span class="fc" id="L3996">        }</span>

        public void initialize() {
<span class="fc" id="L3999">            ThreadExecutor executor = getThreadExecutor();</span>
<span class="fc" id="L4000">            executor.execute(MisfireHandler.this);</span>
<span class="fc" id="L4001">        }</span>

        public void shutdown() {
<span class="fc" id="L4004">            shutdown = true;</span>
<span class="fc" id="L4005">            this.interrupt();</span>
<span class="fc" id="L4006">        }</span>

        private RecoverMisfiredJobsResult manage() {
            try {
<span class="fc" id="L4010">                getLog().debug(&quot;MisfireHandler: scanning for misfires...&quot;);</span>

<span class="fc" id="L4012">                RecoverMisfiredJobsResult res = doRecoverMisfires();</span>
<span class="fc" id="L4013">                numFails = 0;</span>
<span class="fc" id="L4014">                return res;</span>
<span class="fc" id="L4015">            } catch (Exception e) {</span>
<span class="pc bpc" id="L4016" title="1 of 2 branches missed.">                if(numFails % 4 == 0) {</span>
<span class="fc" id="L4017">                    getLog().error(</span>
                        &quot;MisfireHandler: Error handling misfires: &quot;
<span class="fc" id="L4019">                                + e.getMessage(), e);</span>
                }
<span class="fc" id="L4021">                numFails++;</span>
            }
<span class="fc" id="L4023">            return RecoverMisfiredJobsResult.NO_OP;</span>
        }

        @Override
        public void run() {
            
<span class="fc bfc" id="L4029" title="All 2 branches covered.">            while (!shutdown) {</span>

<span class="fc" id="L4031">                long sTime = System.currentTimeMillis();</span>

<span class="fc" id="L4033">                RecoverMisfiredJobsResult recoverMisfiredJobsResult = manage();</span>

<span class="fc bfc" id="L4035" title="All 2 branches covered.">                if (recoverMisfiredJobsResult.getProcessedMisfiredTriggerCount() &gt; 0) {</span>
<span class="fc" id="L4036">                    signalSchedulingChangeImmediately(recoverMisfiredJobsResult.getEarliestNewTime());</span>
                }

<span class="fc bfc" id="L4039" title="All 2 branches covered.">                if (!shutdown) {</span>
<span class="fc" id="L4040">                    long timeToSleep = 50l;  // At least a short pause to help balance threads</span>
<span class="pc bpc" id="L4041" title="1 of 2 branches missed.">                    if (!recoverMisfiredJobsResult.hasMoreMisfiredTriggers()) {</span>
<span class="fc" id="L4042">                        timeToSleep = getMisfireThreshold() - (System.currentTimeMillis() - sTime);</span>
<span class="pc bpc" id="L4043" title="1 of 2 branches missed.">                        if (timeToSleep &lt;= 0) {</span>
<span class="nc" id="L4044">                            timeToSleep = 50l;</span>
                        }

<span class="fc bfc" id="L4047" title="All 2 branches covered.">                        if(numFails &gt; 0) {</span>
<span class="fc" id="L4048">                            timeToSleep = Math.max(getDbRetryInterval(), timeToSleep);</span>
                        }
                    }
                    
                    try {
<span class="fc" id="L4053">                        Thread.sleep(timeToSleep);</span>
<span class="fc" id="L4054">                    } catch (Exception ignore) {</span>
<span class="fc" id="L4055">                    }</span>
                }//while !shutdown
<span class="fc" id="L4057">            }</span>
<span class="fc" id="L4058">        }</span>
    }
}

// EOF
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>